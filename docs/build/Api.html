<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Detailed API · Unveil.jl Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="Quickguide.html">Unveil.jl Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="Quickguide.html">Quick guide</a></li><li><a class="tocitem" href="Unveil.html">Main functions of Unveil</a></li><li><a class="tocitem" href="Others.html">Functions used by Unveil and more</a></li><li class="is-active"><a class="tocitem" href="Api.html">Detailed API</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Unveil"><span>Unveil</span></a></li><li class="toplevel"><a class="tocitem" href="#Data_preparation"><span>Data_preparation</span></a></li><li class="toplevel"><a class="tocitem" href="#PCA"><span>PCA</span></a></li><li class="toplevel"><a class="tocitem" href="#SWO"><span>SWO</span></a></li><li class="toplevel"><a class="tocitem" href="#CVI"><span>CVI</span></a></li><li class="toplevel"><a class="tocitem" href="#Graphical-representations"><span>Graphical representations</span></a></li><li class="toplevel"><a class="tocitem" href="#Function-for-fBms-data-based"><span>Function for fBms data based</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions-for-Data-Analysis"><span>Functions for Data Analysis</span></a></li><li class="toplevel"><a class="tocitem" href="#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations"><span>WORK IN PROGRESS : Function for Structure functions computations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Api.html">Detailed API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Api.html">Detailed API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/Api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h1><h1 id="Unveil"><a class="docs-heading-anchor" href="#Unveil">Unveil</a><a id="Unveil-1"></a><a class="docs-heading-anchor-permalink" href="#Unveil" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Unveil.combinecv-Tuple{}" href="#Unveil.combinecv-Tuple{}"><code>Unveil.combinecv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WORK IN PROGRESS Combine multiple CV maps into one cube.  Use this script in a julia terminal with :     julia&gt;Unveil.combinecv()</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.convpca-Tuple{Any}" href="#Unveil.convpca-Tuple{Any}"><code>Unveil.convpca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convpca(VARFILEPATH)</code></pre><p>Produce calculations to find the PCA convergence criteria based on the matrix projection from PCA. No PCA reconstructed cube will be saved. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/convpca.txt&#39;).</p><p>OUTPUTS : A plots with every moments of the projection matrix + the metric (see the doc). Also add a .dat file with moments, metric and number of PC used for each.</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.convpca(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.convswo-Tuple{Any}" href="#Unveil.convswo-Tuple{Any}"><code>Unveil.convswo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convswo(VARFILEPATH)</code></pre><p>Look for the best interval to integrate the spectra for the window optimisation process. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/convswo.txt&#39;).</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.convswo(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.cv-Tuple{Any}" href="#Unveil.cv-Tuple{Any}"><code>Unveil.cv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv(VARFILEPATH)</code></pre><p>Calculate the CV from a cube given in input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/cv.txt&#39;).</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.cv(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.cvcvi-Tuple{Any}" href="#Unveil.cvcvi-Tuple{Any}"><code>Unveil.cvcvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvcvi(VARFILEPATH)</code></pre><p>Calculate the CV and CVI from a cube given in input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/cvcvi.txt&#39;).</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.cvcvi(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.cvi-Tuple{Any}" href="#Unveil.cvi-Tuple{Any}"><code>Unveil.cvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvi(VARFILEPATH)</code></pre><p>Calculate the CVI from a CV map. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/cvi.txt&#39;). </p><p>INPUT : path to the variable &#39;.txt&#39; file OUTPUTS : Save the CV fits, </p><p>Use this script in a julia terminal with :     julia&gt;Unveil.cvi(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.multipca-Tuple{Any}" href="#Unveil.multipca-Tuple{Any}"><code>Unveil.multipca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multipca(VARFILEPATH)</code></pre><p>Use multiple PCA processes on a cube and with multiple numbers of PCs given as input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/multipca.txt&#39;).</p><p>OUTPUTS : One file per cube reconstructed with one of the number of PC given as an input.</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.multipca(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.pca-Tuple{Any}" href="#Unveil.pca-Tuple{Any}"><code>Unveil.pca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pca(VARFILEPATH)</code></pre><p>Use a PCA (Principal Component Analysis) process on a cube and with N PCs given as input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/pca.txt&#39;). </p><p>INPUTS : path to the variable &#39;.txt&#39; file OUTPUTS : save a cube reconstructed by the number of PC asked in the &#39;.txt&#39; file</p><p>Use this function in a julia terminal with :     julia&gt; Unveil.pca(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.swo-Tuple{Any}" href="#Unveil.swo-Tuple{Any}"><code>Unveil.swo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swo(VARFILEPATH)</code></pre><p>Use a SWO (Spectral Window Optimisation) process on a cube. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/swo.txt&#39;).</p><p>Use this function in a julia terminal with :     julia&gt; Unveil.swo(VARFILEPATH)</p></div></section></article><h1 id="Data_preparation"><a class="docs-heading-anchor" href="#Data_preparation">Data_preparation</a><a id="Data_preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data_preparation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.addblank-NTuple{4, Any}" href="#Data_preparation.addblank-NTuple{4, Any}"><code>Data_preparation.addblank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addblank(data,missing_arr,blank,data_dimension)</code></pre><p>Reconstruct a data with missing values after they where deleted. Usually deleted in order to compute a PCA. Can reconstruct 3D cubes (e.g. PPV) as well as 2D maps (PP). In the first case, the input missing<em>arr should be in 2D, while in the second case it should be in 1D. The input missing</em>arr is produces with the function Data<em>preparation.pca</em>prep. The input data should be a 1D vector. Data_dimension has to be equal to the dimension you want to obtain.      To reproduce a 3D cube, it should have blank values at the exact same positions across the 3rd dimension. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.addmask-NTuple{8, Any}" href="#Data_preparation.addmask-NTuple{8, Any}"><code>Data_preparation.addmask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addmask(cube,colorscale,nbmask,data_dimension,delta_xvec,delta_yvec)</code></pre><p>Blank all the pixels in the third dimension selected manually by the user (using a contour). Can do multiple mask.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.allmissing-Tuple{Any}" href="#Data_preparation.allmissing-Tuple{Any}"><code>Data_preparation.allmissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allmissing(data)</code></pre><p>Return true if the data contain any missing value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.blank_equal-Tuple{Any, Any, Any}" href="#Data_preparation.blank_equal-Tuple{Any, Any, Any}"><code>Data_preparation.blank_equal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blank_equal(array,oldvalue,newvalue)</code></pre><p>Change the values equals to a value by another one in an array. This is useful if change of blanking is desired. You have to use the function &quot;replace_nantoblank&quot; if the old value is NaN.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.blank_inf-Tuple{Any, Any, Any}" href="#Data_preparation.blank_inf-Tuple{Any, Any, Any}"><code>Data_preparation.blank_inf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blank_inf(array,oldvalue,newvalue)</code></pre><p>Change the values tinier than an old value to a new value in an array. This is useful if a change of blanking is desired</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.blank_inf_abs-Tuple{Any, Any, Any}" href="#Data_preparation.blank_inf_abs-Tuple{Any, Any, Any}"><code>Data_preparation.blank_inf_abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blank_inf_abs(array,oldvalue,newvalue)</code></pre><p>Change the values tinier than an old value (its absolute value) to a new value in an array. This is useful if a change of blanking is desired</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.blank_snr-Tuple{Any, Any, Any}" href="#Data_preparation.blank_snr-Tuple{Any, Any, Any}"><code>Data_preparation.blank_snr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blank_snr(data2D,NoiseCan,thresh)</code></pre><p>Blank all the spectra which have a signal to noise ratio inferior than a threshold. Work on 2D data, the first dimension giving the pixel position and the second dimension the spectra referring to this position.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.blank_sup-Tuple{Any, Any, Any}" href="#Data_preparation.blank_sup-Tuple{Any, Any, Any}"><code>Data_preparation.blank_sup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blank_sup(array,oldvalue,newvalue)</code></pre><p>Change the values bigger than an old value to a new value of an array . This is useful if a change of blanking is desired</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.boolmatrix_missing-Tuple{Any}" href="#Data_preparation.boolmatrix_missing-Tuple{Any}"><code>Data_preparation.boolmatrix_missing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boolmatrix_missing(array)</code></pre><p>Return a 1D and a 2D boolean matrices indicating the indexes of missing values in array. Array should be a 2 dimension data (pixels*spectra for example)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.clear_var-NTuple{4, Any}" href="#Data_preparation.clear_var-NTuple{4, Any}"><code>Data_preparation.clear_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_var(var1,var2,var3,var4)</code></pre><p>Replace all variable in input by 0 to &quot;free&quot; space.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.coordtopix-NTuple{5, Any}" href="#Data_preparation.coordtopix-NTuple{5, Any}"><code>Data_preparation.coordtopix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coordtopix(header,coord,unit,ax ; off=true)</code></pre><p>Do the conversion between physical coordinate and pixel number thanks to the header of the data. Works only for small-size fields. Need the unit of the coordinate given (arcsec,arcmin,rad,deg only) and the axis. Consider by default that the coordinate given is an offset (place at the center of the image). The values of CRVAL1... are considered in deg.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.delete_allnotvalue-Tuple{Any, Any}" href="#Data_preparation.delete_allnotvalue-Tuple{Any, Any}"><code>Data_preparation.delete_allnotvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_allnotvalue(data,blank)</code></pre><p>Delete from data all value which are not a valid value, e.g. missing, NaN and blank.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.deletemissing-Tuple{Any, Any}" href="#Data_preparation.deletemissing-Tuple{Any, Any}"><code>Data_preparation.deletemissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deletemissing(data,missing1D)</code></pre><p>Delete all rows where there is at least one missing value using a boolean vector of the missing values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.directory_prep-Tuple{Any}" href="#Data_preparation.directory_prep-Tuple{Any}"><code>Data_preparation.directory_prep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">directory_prep(PATHTOSAVE::String)</code></pre><p>Construct a new directory to save plots of the convergence criteria (Convergence_Criteria) process and another to save the fits (Data).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.lookingfor_interval-Tuple{Any, Any, Any}" href="#Data_preparation.lookingfor_interval-Tuple{Any, Any, Any}"><code>Data_preparation.lookingfor_interval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookingfor_interval(arr,value,sigma)</code></pre><p>Return the array (1D) cut at [value-sigma:value+sigma]. Return also the indices of these values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.noise_channels-Tuple{}" href="#Data_preparation.noise_channels-Tuple{}"><code>Data_preparation.noise_channels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noise_channels()</code></pre><p>Construct a vector with two subranges. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.pca_prep-Tuple{Any, Any}" href="#Data_preparation.pca_prep-Tuple{Any, Any}"><code>Data_preparation.pca_prep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pca_prep(arr,arraydimension)</code></pre><p>Prepare data (given in 2D (pv) or 3D (ppv)) in order to conduct PCA on them by deleting missing values and reshape in 2D.</p><p>Will also check if any missing value still exist in the data, showing that the data are not regularly blanked. Return data in 2 dimensions without missing value, a 1D boolean matrix to check if any missing value still exist in the data (if 0 element then no missing value) and a 2D matrix with booleans corresponding to missing values in the dataset (used to reconstruct the data with the missing values).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.permcolrow-Tuple{Any}" href="#Data_preparation.permcolrow-Tuple{Any}"><code>Data_preparation.permcolrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permcolrow(arr)</code></pre><p>Return the array with the first and second dimensions permuted. 2D and 3D arrays accepted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.pixtocoord-Tuple{Any, Any}" href="#Data_preparation.pixtocoord-Tuple{Any, Any}"><code>Data_preparation.pixtocoord</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pixtocoord(header,unit)</code></pre><p>Do the conversion between pixel number and physical coordinate thanks to the header of the data. Return the X and Y coordinates in the physical coordinates you want, then the X and Y coordinate centered at the middle of the plot.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.read_dim-Tuple{Any}" href="#Data_preparation.read_dim-Tuple{Any}"><code>Data_preparation.read_dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_dim(arr)</code></pre><p>Return a vector with dimensions of the data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.read_fits_pp-Tuple{Any}" href="#Data_preparation.read_fits_pp-Tuple{Any}"><code>Data_preparation.read_fits_pp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_pp(path)</code></pre><p>Read a 2D fits (pixel*pixel). Return values (matrix), header and dimensions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.read_fits_ppf-Tuple{Any}" href="#Data_preparation.read_fits_ppf-Tuple{Any}"><code>Data_preparation.read_fits_ppf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_ppf(field ; path=&quot;none&quot;, check = true) WIP</code></pre><p>Read data of a PPF fits from its path, test if the fits is conform, then return : [1] Data in an array [2] Range of velocity in an array (in km/s) [3] X coordinate in arcsecond [4] Y coordinate in arcsecond [5] X coordinates centered in the middle of the image [6] Y coordinates centered in the middle of the image [7] Dimensions of the data (one vector with each element a dimension) [8] The velocity resolution (in km/s) [9] The header of the fits [10] The path to the fits Make the conversion of frequency into velocity. If the header does not contain any third dimension indication, the function will still return the data, the dimension and the header. Velocities need to be in the third dimension. This function conduct a sanity check by default. Give check = false if you don&#39;t want the test being conducted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.read_fits_ppv-Tuple{Any, Any}" href="#Data_preparation.read_fits_ppv-Tuple{Any, Any}"><code>Data_preparation.read_fits_ppv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_ppv(path,vel_units ; check = true)</code></pre><p>Read data of a PPV fits from its path, test if the fits is conform, then return : [1] Data in an array [2] Range of velocity in an array (in km/s) [3] Dimensions of the data (one vector with each element a dimension) [4] The velocity resolution (in km/s) [5] The header of the fits If the header does not contain any third dimension indication, the function will still return the data, the dimension and the header. Velocities need to be in the third dimension. This function conduct a sanity check by default. Give check = false if you don&#39;t want the test being conducted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.read_fits_spect-Tuple{Any, Any}" href="#Data_preparation.read_fits_spect-Tuple{Any, Any}"><code>Data_preparation.read_fits_spect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_spect(path,vel_units )</code></pre><p>Read data of a spectra PV fits from the path of the field and return : [1] an array of the data [2] an array of the range of velocity (in km/s) [3] the velocity resolution (in km/s) [4] the header of the fits [5] the file of the fits</p><p>Velocities need to be in the second dimension. By default, the path of the fits is &quot;none&quot;, because we usually use local path listed in the function data_path.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.read_fits_velocityvector-Tuple{Any, Any}" href="#Data_preparation.read_fits_velocityvector-Tuple{Any, Any}"><code>Data_preparation.read_fits_velocityvector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_velocityvector(path,vel_units)</code></pre><p>Reconstruct the velocity vector of a fits file. Have to specify the units of the velocity vector of the fits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.read_var_files-Tuple{Any}" href="#Data_preparation.read_var_files-Tuple{Any}"><code>Data_preparation.read_var_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_var_files(varfile_path)</code></pre><p>A function to read and import values of a variable files. The variable files can be anywhere in the machine, but preferentially localised in the &quot;var_file&quot; folders.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.regular_blanking-Tuple{Any}" href="#Data_preparation.regular_blanking-Tuple{Any}"><code>Data_preparation.regular_blanking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regular_blanking(data)</code></pre><p>Check if the data of a fits file contains any irregular blanking e.g. a spectra with one blanking value (or more, but less than the spectra size).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.replace_blanktomissing-Tuple{Any, Any}" href="#Data_preparation.replace_blanktomissing-Tuple{Any, Any}"><code>Data_preparation.replace_blanktomissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_blanktomissing(arr,blanktomissing)</code></pre><p>Replace specific values (blanktomissing, generally blank value) by missing value in an array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.replace_inf_in_nan-Tuple{Any}" href="#Data_preparation.replace_inf_in_nan-Tuple{Any}"><code>Data_preparation.replace_inf_in_nan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_inf_in_nan(arr)</code></pre><p>Replace the Inf values by NaN values. Useful when searching for max and min values in the array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.replace_missingtoblank-Tuple{Any, Any}" href="#Data_preparation.replace_missingtoblank-Tuple{Any, Any}"><code>Data_preparation.replace_missingtoblank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_missingtoblank(arr,missingtoblank)</code></pre><p>Replace missing values by a &#39;missingtoblank&#39; value in an array (generally a blank value).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.replace_nantoblank-Tuple{Any, Any}" href="#Data_preparation.replace_nantoblank-Tuple{Any, Any}"><code>Data_preparation.replace_nantoblank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_nantoblank(data,blank)</code></pre><p>Replace the NaN values in an array by a new blank value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.replace_nantomissing-Tuple{Any}" href="#Data_preparation.replace_nantomissing-Tuple{Any}"><code>Data_preparation.replace_nantomissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_nantomissing(data)</code></pre><p>Replace the NaN values in an array by missing value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.valid_header-Tuple{Any}" href="#Data_preparation.valid_header-Tuple{Any}"><code>Data_preparation.valid_header</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    valid_header(header)

Check if the header of a fits file contains a blank, a bzero, and a bscale values.</code></pre><p>If not, return an error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.wait_for_key-Tuple{}" href="#Data_preparation.wait_for_key-Tuple{}"><code>Data_preparation.wait_for_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wait_for_key(; prompt = &quot;Press any key&quot;, io = stdin))</code></pre><p>Pause the script until the user press a key. The text prompt can be changed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.write_cv_fits-Tuple{String, String, String, Any, Any, Any}" href="#Data_preparation.write_cv_fits-Tuple{String, String, String, Any, Any, Any}"><code>Data_preparation.write_cv_fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_cv_fits(fitstocopy::String,newname::String,data,datadim,blank ; pc=0,varpercent=100)</code></pre><p>Create a fits file used for cv reconstructed data. Contains on its header the number of pc used (default=0), the percentage of variance explained (default=100), the lag and the angle. Need a fits to copy its header entries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.write_cvi_fits-Tuple{Any, String, String, String, Any, Any, Any}" href="#Data_preparation.write_cvi_fits-Tuple{Any, String, String, String, Any, Any, Any}"><code>Data_preparation.write_cvi_fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_cvi_fits(lag,fitstocopy::String,newname::String,data,datadim,blank; pc=0,varpercent=100)</code></pre><p>Create a fits used for cvi map. Contains on its header the lag used to do the cvi. Possibility to add in the header the number of PC used if data reconstructed from a PCA and the percentage of variance reproduced thank&#39;s to the PCA.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.write_dat-Tuple{Any, Any, Any}" href="#Data_preparation.write_dat-Tuple{Any, Any, Any}"><code>Data_preparation.write_dat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>write_dat(matrix,PATHTOSAVE,NAME ; more=[&quot;&quot;], overwrite=false)</p><p>Write matrix in a .dat file. Each column of the matrix is writen as new column in the file. Delimiters are spaces by default. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true. If want to add more entries on the header of the dat, use the option &#39;more&#39;. Will be added as commentaries with a # at the begining of the line.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.write_fits-Tuple{String, String, String, Any, Any, Any}" href="#Data_preparation.write_fits-Tuple{String, String, String, Any, Any, Any}"><code>Data_preparation.write_fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_fits(fitstocopy::String,newname::String,pathtosave::String,datatosave,datadim,blank ; finished=true)</code></pre><p>Create a fits with its own header based on &#39;fitstocopy&#39;, and with the name &#39;newfits&#39;. DO NOT ADD THE EXTENSION (e.g &quot;.fits&quot;) FOR THE NAME OF THE NEWFITS). Need to give the blanking value. The fits can be constructed by data with two dimensions or three dimensions. Variable &#39;finished&#39; is by default true, so the function will by default close the new fits file at the end of the execution of this function. If &#39;finished&#39; is false, the function will not close the fits file, allowing it to be modified again in another function (create<em>cvi</em>fits for example). If want to add more entries on the header, use the option &#39;more&#39;. Alternate between the name printed in the header and the value. Example, if want to add an entry for &#39;imsize&#39; equals to 50, and an entry for &#39;powerlaw&#39; equals to -3, write : more=[&quot;imsize&quot;,&quot;50&quot;,&quot;powerlaw&quot;,&quot;-3&quot;]. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_preparation.write_pca_fits-Tuple{Any, Any, String, String, String, Any, Any, Any}" href="#Data_preparation.write_pca_fits-Tuple{Any, Any, String, String, String, Any, Any, Any}"><code>Data_preparation.write_pca_fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_pca_fits(pc,varpercent,fitstocopy::String,newname::String,data,datadim,blank)</code></pre><p>Create a fits used for pca reconstructed data. Contains on its header the number of pc used and the percentage of variance explained. Need a fits to copy its header entries.</p></div></section></article><h1 id="PCA"><a class="docs-heading-anchor" href="#PCA">PCA</a><a id="PCA-1"></a><a class="docs-heading-anchor-permalink" href="#PCA" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.convergence_moments_byintegration-NTuple{8, Any}" href="#Functionforpca.convergence_moments_byintegration-NTuple{8, Any}"><code>Functionforpca.convergence_moments_byintegration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    convergence_moments_byintegration(data2D,integration_range,pcnumber,velocity_increment,M,Yt,datadim,velocity_vector,IM)</code></pre><p>Return the I-th moment order of the integrated by sections spectras differences, from arrays reconstructed with N PC and arrays without PCA. Also return the new velocity vector where each value is centered on the integrated sections. The function integrate by section (the integration_range) spectra from reconstructed and non-reconstructed data, then compute the given moment order of their differences. Data should be in 2 dimensions (PV cube), and datadim should refers to the dimension of the 3D data cube (PPV). Pcnumber should be a vector with all the number of PC you want (example Vector(1:10)).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.cv_convergence-NTuple{5, Any}" href="#Functionforpca.cv_convergence-NTuple{5, Any}"><code>Functionforpca.cv_convergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    cv_convergence(pcmax,M,Yt,velocity_vector,datadim)</code></pre><p>Return a cube reconstructed with different number of PC, its first and its second velocity moment order. The cube considered is the one processed by PCA, that gave M and Yt as a result. The arrays in output are in 3D, where the third dimensions gives results for different number of PC used. Datadim should be the dimension of the 3D initial PPV cube. M is a PCA type, produced by the function pca. Yt is a vector or a matrix where each column gives the principal components of an observation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.intensity_moments_specific_channels-Tuple{Any, Any, Any}" href="#Functionforpca.intensity_moments_specific_channels-Tuple{Any, Any, Any}"><code>Functionforpca.intensity_moments_specific_channels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    intensity_moments_specific_channels(arr_path,channels,datadim)</code></pre><p>Will compute the first, second, third and fourth, moments order of the mean of given channels in a data cube. The cube is not given as input but only the path where it is saved as a &#39;bin&#39; temporary file (saving RAM). Datadim refer to the dimension of the 3D data cube (the original data cube).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.intensity_moments_specific_channels_withPCA-Tuple{Any, String, Any, Any, Any}" href="#Functionforpca.intensity_moments_specific_channels_withPCA-Tuple{Any, String, Any, Any, Any}"><code>Functionforpca.intensity_moments_specific_channels_withPCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    intensity_moments_specific_channels_withPCA(M,Yt_path::String,pcnumber,canals,datadim)</code></pre><p>Will compute the first, second, third and fourth moments order of the mean of specific canals in the data reconstructed with different number of PC to check if they are converging. Datadim refer to the dimension of the 3D data cube (the original data cube). M is a PCA type, produced by the function pca. Yt_path is the path where Yt is saved as a &#39;bin&#39; temporary fil. Yt is a vector or a matrix where each column gives the principal components of an observation. M and Yt are obtained with the function pca. Moment order can be any Int from 1 to 4. Return one 1D array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.intensity_moments_specific_channels_withPCASVDRAND-NTuple{4, Any}" href="#Functionforpca.intensity_moments_specific_channels_withPCASVDRAND-NTuple{4, Any}"><code>Functionforpca.intensity_moments_specific_channels_withPCASVDRAND</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    intensity_moments_specific_channels_withPCASVDRAND(svdobject,pcnumber,channels,p)</code></pre><p>Same as intensity<em>moments</em>specific<em>channels</em>withPCA but using a Principal Component Analysis based on random SVD.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.multiple_moment!-NTuple{8, Any}" href="#Functionforpca.multiple_moment!-NTuple{8, Any}"><code>Functionforpca.multiple_moment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    multiple_moment!</code></pre><p>Same as multiple_moment but on pre-allocated data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.multiple_moment-NTuple{5, Any}" href="#Functionforpca.multiple_moment-NTuple{5, Any}"><code>Functionforpca.multiple_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    multiple_moment(velvector,data_dimension,M,Yt,pcmax)</code></pre><p>Compute first and second velocity moment order of multiple data cube. The data cubes are reconstructed from PCA with different number of PC.  M is a PCA type, produced by the function pca. Yt is a vector or a matrix where each column gives the principal components of an observation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.multiplepca-NTuple{4, Any}" href="#Functionforpca.multiplepca-NTuple{4, Any}"><code>Functionforpca.multiplepca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    multiplepca(M,Yt,pcnumber,datadim)</code></pre><p>Do multiple PCA with different number of PC on the same data. Will return a 3D array, with pixel position in the first dimension, velocity in the second dimension, and the data reconstructed with a specific number of pc in the third dimension. Pcnumber should be a vector with all the number of PC you want (example Vector(1:10)).  M is a PCA type, produced by the function pca. Yt is a vector or a matrix where each column gives the principal components of an observation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.pca-Tuple{Any, Integer, String}" href="#Functionforpca.pca-Tuple{Any, Integer, String}"><code>Functionforpca.pca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca(data2D,pc::Integer,path::String ; percent=1.0)</code></pre><p>Produce a Principal Component Analysis on a data, using &#39;pc&#39; number of principal component. &#39;percent&#39; gives the wanted percentage of variance reconstructed (default=1). &#39;path&#39; is the path where results will be saved (in &#39;bin&#39; temporary files, named as mmap<em>Yt.bin, mmap</em>Mproj.bin and mmap<em>Mmean.bin) Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the path to the projections of the data2D on the PC axis, the mean of these projections, the path to the matrix composed of the principal components in columns and the percentage of explained variance. These results will allow to reconstruct the cube with a given number of PC (using pca</em>nomorecalc).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.pca-Tuple{Any, Integer}" href="#Functionforpca.pca-Tuple{Any, Integer}"><code>Functionforpca.pca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca(data2D,pc::Integer ; percent=1.0)</code></pre><p>Produce a Principal Component Analysis on a data, using &#39;pc&#39; number of principal component. &#39;percent&#39; gives the wanted percentage of variance reconstructed (default=1).  Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the pca fit M (a type created by the MultivariateStats package), the matrix composed of the principal components in columns, the percentage of explained variance and the data reconstructed with &#39;pc&#39; number of principal component. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.pca_nomorecalc-NTuple{5, Any}" href="#Functionforpca.pca_nomorecalc-NTuple{5, Any}"><code>Functionforpca.pca_nomorecalc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim)</code></pre><p>Reconstruct data with a certain number of PC, without redo all of the PCA calculation. Necessary to do a first pca calculation to run this one, because needed M (a new type related to PCA constructed by MultivariateStats package) and Yt (matrix with each column a PC). Datadim should be a tuple with two values (PV cube, 2D) or three (PPV cube, 3D).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.pca_nomorecalc-Tuple{String, String, String, Any, Any, Any}" href="#Functionforpca.pca_nomorecalc-Tuple{String, String, String, Any, Any, Any}"><code>Functionforpca.pca_nomorecalc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca_nomorecalc(Mproj_path::String,Yt_path::String,Mmean_path::String,pcfirst,pclast,datadim)</code></pre><p>Same as pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim) but using here the path to the temporary files containing the informations (M and Yt). To be used after pca(data2D,pc::Integer,path::String ; percent=1.0) in order to produce a reconstructed cube.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforpca.variance_evolution-Tuple{Any, Any}" href="#Functionforpca.variance_evolution-Tuple{Any, Any}"><code>Functionforpca.variance_evolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    variance_evolution(M,threshold)</code></pre><p>Return an Array with the numbers of PC explaining a percentage of the data variance tinier (or equal) than the threshold given in input.</p></div></section></article><h1 id="SWO"><a class="docs-heading-anchor" href="#SWO">SWO</a><a id="SWO-1"></a><a class="docs-heading-anchor-permalink" href="#SWO" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Spectralwindowopti.convoptiwind-NTuple{9, Any}" href="#Spectralwindowopti.convoptiwind-NTuple{9, Any}"><code>Spectralwindowopti.convoptiwind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convoptiwind(cubesource,DATADIMENSION,VELOCITYVECTOR,NOISECAN,BLANK,RANGE,PATHTOSAVE)</code></pre><p>DATADIMENSION should be 2D : PV</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Spectralwindowopti.optiwind-NTuple{6, Any}" href="#Spectralwindowopti.optiwind-NTuple{6, Any}"><code>Spectralwindowopti.optiwind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optiwind(cube,DATADIMENSION,VELOCITYVECTOR,NOISECAN,BLANK,RANGE)</code></pre><p>INPUT DESCRIPTION Method of window optimisation. Search for the limits of the signals in each spectrum of the cube. The cube given as input should be in 2Dimensions, with spectrum ordonnated by row. A first CV computation on each spectra should also be given as input : cvmap. Cvmap is in 1D, with each position corresponding to the spectrum of the same position in the 2D cube. The velocity vector should also be given (obtained by Data<em>preparation.read</em>fits_ppv). NOISECAN corresponds to a Vector{Int64} of 2 entries, where each entry corresponds to a position in the Velocity Vector of a noise cannal : they have to englobe only noise. Used to compute the noise rms ; ESSENTIAL IN THE COMPUTATION. The last value RANGE is the size of the increment used during the computation : lower it is and longer the code will be. </p><p>METHOD  A first initialisation of a mask of same size than the input cube, with 0 everywhere. For each spectra, compute the intensity area by velocity increments from each side of its CV value. When the integration is lower than sqrt{N}*NoiseRMS, the limit is kept (with N the number of velocity cannals used for the integration and NoiseRMS the noise rms). When the two limits are obtained, change values of the mask from 0 to 1 inside these limits for each spectra. Last, multiplication of the mask to the cube. </p><p>OUTPUT DESCRIPTION   Return the cube masked and the mean of the noise accross the map (one sigma).</p></div></section></article><h1 id="CVI"><a class="docs-heading-anchor" href="#CVI">CVI</a><a id="CVI-1"></a><a class="docs-heading-anchor-permalink" href="#CVI" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.construct_cvimap!-Tuple{Any, Int64, Any, Any, Array{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}}" href="#Functionforcvi.construct_cvimap!-Tuple{Any, Int64, Any, Any, Array{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}}"><code>Functionforcvi.construct_cvimap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap!(xyarr,Lag::Int64,nangle,mapdim,cvi_averaged::Array{Union{Missing, Float64}},cvi_allangle::Array{Union{Missing,Float64},3}; diff=&quot;relative&quot;,keepmissing=true)</code></pre><p>Will construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cvi<em>averaged), and another for the cvi calculated with all angle and lag (cvi</em>allangle). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.construct_cvimap!-Tuple{Any, Vector{Int64}, Any, Any, Matrix{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}, Array{Union{Missing, Float64}, 3}}" href="#Functionforcvi.construct_cvimap!-Tuple{Any, Vector{Int64}, Any, Any, Matrix{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}, Array{Union{Missing, Float64}, 3}}"><code>Functionforcvi.construct_cvimap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap!(xyarr,Lag::Vector{Int64},nangle,mapdim,cvi_averaged_alllag::Array{Union{Missing, Float64},2},cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle::Array{Union{Missing,Float64},3}; diff=&quot;relative&quot;,keepmissing=true)</code></pre><p>Will construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cvimean), and another for the cvi calculated with all angle and lag (cvi<em>allangle</em>alllag). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.construct_cvimap-Tuple{Any, Int64, Any, Any}" href="#Functionforcvi.construct_cvimap-Tuple{Any, Int64, Any, Any}"><code>Functionforcvi.construct_cvimap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap(cvmap,Lag::Int64,nangle,mapdim; diff=&quot;relative&quot;,keepmissing=true)</code></pre><p>Same as construct_cvimap if Lag is a Int64 of one lag. Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.construct_cvimap-Tuple{Any, Vector{Int64}, Any, Any}" href="#Functionforcvi.construct_cvimap-Tuple{Any, Vector{Int64}, Any, Any}"><code>Functionforcvi.construct_cvimap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap(cvmap,Lag::Vector{Int64},nangle,mapdim; diff=&quot;relative&quot;,keepmissing=true,BLANK=-1000)</code></pre><p>Construct a Centroid Velocity Increment map based on a &#39;cvmap&#39;. The cvi map is constructed by taking the mean of all rotations of the Centroid Velocity Increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.construct_cvmap-Tuple{Any, Any}" href="#Functionforcvi.construct_cvmap-Tuple{Any, Any}"><code>Functionforcvi.construct_cvmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvmap(xyarr,velvector)</code></pre><p>Will construct a cv map by calculating the first velocity moment order of the array and replace the inf values by NaN. xyarr have to be in 2D (pixel*pixel), while velvector have to be in 1D (velocities).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.cv_increment!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}, 3}}" href="#Functionforcvi.cv_increment!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}, 3}}"><code>Functionforcvi.cv_increment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment!(xyarr,Lag::Int64,blank,cvimap_lag::Array{Union{Missing,Float64},2})</code></pre><p>Same as (xyarr,Lag::Int64,nangle; diff=&quot;relative&quot;,periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cvi_allangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.cv_increment!-Tuple{Any, Vector{Int64}, Any, Array{Union{Missing, Float64}, 3}, Any}" href="#Functionforcvi.cv_increment!-Tuple{Any, Vector{Int64}, Any, Array{Union{Missing, Float64}, 3}, Any}"><code>Functionforcvi.cv_increment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment!(xyarr,Lag::Vector{Int64},nangle,cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle ; diff=&quot;relative&quot;,periodic=false)</code></pre><p>Same as cv<em>increment(xyarr,Lag::Vector{Int64},nangle; diff=&quot;relative&quot;,periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cvi</em>allangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle) and cvi<em>allangle</em>alllag = Array{Union{Missing,Float64},3}(undef,DataDimension[1]*DataDimension[2],nangle,size(Lag)[1])</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.cv_increment-Tuple{Any, Int64, Any, Any}" href="#Functionforcvi.cv_increment-Tuple{Any, Int64, Any, Any}"><code>Functionforcvi.cv_increment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment(xyarr,Lag::Int64,nangle; diff=&quot;relative&quot;,periodic=false)</code></pre><p>Compute the centroid velocity increment of xyarr at one Lag. Nangle is the number of angle using to compute the differences (it&#39;s a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first two dimensions equal to the size of the map, and the third dimension is the cvi computed at each angle.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.cv_increment-Tuple{Any, Vector{Int64}, Any}" href="#Functionforcvi.cv_increment-Tuple{Any, Vector{Int64}, Any}"><code>Functionforcvi.cv_increment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment(xyarr,Lag::Vector{Int64},nangle; diff=&quot;relative&quot;,periodic=false)</code></pre><p>Compute the centroid velocity increment of xyarr at multiple Lag values. Nangle is the number of angle using to compute the differences (it&#39;s a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first dimension equal to the size of the map (pixel square), the second dimension is the cvi computed at each angle, and the third dimension is for each value of Lag.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.delete_aberations-Tuple{Any, Any}" href="#Functionforcvi.delete_aberations-Tuple{Any, Any}"><code>Functionforcvi.delete_aberations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_aberations(arr1,arr2)</code></pre><p>Replace values in arr1 which are higher or lower than values in arr2 by missing. Don&#39;t use an arr1 with missing values !</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.moment_four-Tuple{Any, Any}" href="#Functionforcvi.moment_four-Tuple{Any, Any}"><code>Functionforcvi.moment_four</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_four(yarr,xarr)</code></pre><p>Return the fourth moment order of xarr weighted by yarr.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.moment_one-Tuple{Any, Any}" href="#Functionforcvi.moment_one-Tuple{Any, Any}"><code>Functionforcvi.moment_one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_one(yarr,xarr)</code></pre><p>Compute the first moment order of the array xarr weighted by yarr. Centroid = int(T*v)dv/int(T)dv</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.moment_one_field-Tuple{Any, Any, Any}" href="#Functionforcvi.moment_one_field-Tuple{Any, Any, Any}"><code>Functionforcvi.moment_one_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_one_field(arr,velvector)</code></pre><p>Return the first moment order of all pixels in an entire field, weighted by velvector. Arr can be a 3D array (ppv) or a 2D array (pv)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.moment_three-Tuple{Any, Any}" href="#Functionforcvi.moment_three-Tuple{Any, Any}"><code>Functionforcvi.moment_three</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_three(yarr,xarr)</code></pre><p>Return the third moment order of xarr weighted by yarr.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.moment_two-Tuple{Any, Any}" href="#Functionforcvi.moment_two-Tuple{Any, Any}"><code>Functionforcvi.moment_two</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_two(yarr,xarr)</code></pre><p>Return the second moment order of xarr weighted by yarr.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.moment_two_field-Tuple{Any, Any}" href="#Functionforcvi.moment_two_field-Tuple{Any, Any}"><code>Functionforcvi.moment_two_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_two_field(arr,velvector)</code></pre><p>Return the order 2 moment of an entire field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforcvi.multiple_moment-Tuple{Array{Float64, 3}, Any}" href="#Functionforcvi.multiple_moment-Tuple{Array{Float64, 3}, Any}"><code>Functionforcvi.multiple_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiple_moment(cube::Array{Float64,3},velvector)</code></pre><p>Return the first or second velocity moment order of a 3D array. The 3D array in input have its first dimension giving the pixel position, the second dimension giving spectra, and the third dimension giving other data with the same dimensions. This function was built in order to obtain in the third dimensions multiple centroid velocity maps with data reconstructed from different number of principal component (see Principal Component Analysis)</p></div></section></article><h1 id="Graphical-representations"><a class="docs-heading-anchor" href="#Graphical-representations">Graphical representations</a><a id="Graphical-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Graphical-representations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Graphic.StcFct-NTuple{4, Any}" href="#Graphic.StcFct-NTuple{4, Any}"><code>Graphic.StcFct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StcFct()</code></pre><p>Plot structure functions of orders p in function of the structure function of order 3. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.StcFctExponent-NTuple{7, Any}" href="#Graphic.StcFctExponent-NTuple{7, Any}"><code>Graphic.StcFctExponent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StcFctExponent(zeta,third_order_zeta,OrderP,xlim,ylim,labs,data_name_title,directories_name; add=false,save=true,pcfinal=0)</code></pre><p>Plot the exponent of the structure function power-law fit in function of the order p of the structure function. If add is true, the plot will be added on the actual plot. Also add a y=1/3x line on the plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.StcFctExponentWithError-NTuple{10, Any}" href="#Graphic.StcFctExponentWithError-NTuple{10, Any}"><code>Graphic.StcFctExponentWithError</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StcFctExponentWithError()

Plot the exponent of the structure function power-law fit in function of the order p of the structure function. Compute and plot also the error of the fit. If add is true, the plot will be added on the actual plot. Also add a y=1/3x line on the plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.StcFctWithFit-NTuple{6, Any}" href="#Graphic.StcFctWithFit-NTuple{6, Any}"><code>Graphic.StcFctWithFit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StcFctWithFit()</code></pre><p>Plot structure functions of orders p in function of the structure function of order 3 with the fit used to obtain the power-law exponent. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.animate_ppvcube-Tuple{Any, Any, Any}" href="#Graphic.animate_ppvcube-Tuple{Any, Any, Any}"><code>Graphic.animate_ppvcube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">animate_ppvcube(cube,data_name)</code></pre><p>Plot a heatmap of a 3D cube along third dimension, and save it as a gif file.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.animate_spectra-NTuple{5, Any}" href="#Graphic.animate_spectra-NTuple{5, Any}"><code>Graphic.animate_spectra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">animate_spectra(arr,positionnumber,direction)</code></pre><p>Make an animation (.gif) plotting all the spectrum of a line of pixels (dims=1) or a row of pixels (dims=2). Array has to be 3D. Used the array, the position of the line or the row, and the direction (line=1 or row=2).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.checkwindowopti-NTuple{5, Any}" href="#Graphic.checkwindowopti-NTuple{5, Any}"><code>Graphic.checkwindowopti</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.contourmap-NTuple{5, Any}" href="#Graphic.contourmap-NTuple{5, Any}"><code>Graphic.contourmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contourmap(arr,arraytocontour,lev,xvec,yvec)</code></pre><p>Plot the data arr in heatmap type and contours in front at levels=lev. Contours can be provided from another data. Arr has to be 2D.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.corner_cvimap-NTuple{5, Any}" href="#Graphic.corner_cvimap-NTuple{5, Any}"><code>Graphic.corner_cvimap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">corner_cvimap(array1,array2,datadim,labelarray1,labelarray2)</code></pre><p>Make a cornerplot between each element of the third dimension of array2, and also compare with array1. Array1 has to be 1D (cvi pixel values), and array2 has to be 2D (cvi pixel values and different cvi maps obtained (with different PC for example)). Labelarray1 has to be 1 String, Labelarray2 has to be an array os String, with as elements as the third dimension of array2. [&quot;dollars(ix) PC&quot; for ix=2:4] to label the named of the third dimension of array2 has number of PC used</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.cvi_pdf-NTuple{10, Any}" href="#Graphic.cvi_pdf-NTuple{10, Any}"><code>Graphic.cvi_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvi_pdf(data,para0,bin,ylim1,ylim2,alph,Lag,data_name_title,legend ; add=false)</code></pre><p>Plot the pdf of the cvi, WIP : and add a gaussian fit on the data. By default, will do a new plot. If add=true, will add this plot on the last figure created.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.cvi_pdf_norm-Tuple{KernelDensity.UnivariateKDE, Any, Any, Any, Any, Any, Any}" href="#Graphic.cvi_pdf_norm-Tuple{KernelDensity.UnivariateKDE, Any, Any, Any, Any, Any, Any}"><code>Graphic.cvi_pdf_norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvi_pdf_norm(data,sigm,bin,ylim1,ylim2,alph,Lag,data_name_title,legend ; add=false)</code></pre><p>Plot the pdf of the cvi, WIP : and add a gaussian fit on the data. By default, will do a new plot. If add=true, will add this plot on the last figure created.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.heatmap_compare_multiplepc-Tuple{Any, Any, Any, Any, Any, Any, Any, String, Bool, Any}" href="#Graphic.heatmap_compare_multiplepc-Tuple{Any, Any, Any, Any, Any, Any, Any, String, Bool, Any}"><code>Graphic.heatmap_compare_multiplepc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_rawpc(xvec1,yvec1,array1,dimens,xvec2,yvec2,arraypc,title1::String,saveall::Bool,field)</code></pre><p>Plot multiple files, each with two heatmap : the first is a heatmap of the array1 (same for all file), the second a heatmap of the arraypc which change for each file in order to plot all of its third dimension (Data reconstructed with different number of PC for example). Array1 has to be 2D (Pixel<em>Pixel), arraypc has to be 3D (Pixel</em>Pixel*PC). The subplots of each files have the same colorscale.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.heatmap_interacted-Tuple{Any, Any, Any}" href="#Graphic.heatmap_interacted-Tuple{Any, Any, Any}"><code>Graphic.heatmap_interacted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heatmap_interacted(data,delta_xvec,delta_yvec)</code></pre><p>Will produce a heatmap plot of a 2d dataset, with colorscale changing by an interaction of the user on a slider.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.heatmap_subplot_same-Tuple{Any, Any, Any}" href="#Graphic.heatmap_subplot_same-Tuple{Any, Any, Any}"><code>Graphic.heatmap_subplot_same</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heatmap_subplot_same(arr,j,velocity_range)</code></pre><p>Made a subplot in a heatmap form, using the one data but plotting different velocity canals (velocity_range). J is the position of the first plot.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.heatmap_subplot_two-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, String, String, Bool, Any, Any}" href="#Graphic.heatmap_subplot_two-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, String, String, Bool, Any, Any}"><code>Graphic.heatmap_subplot_two</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heatmap_subplot_two(xvec1,yvec1,array1,xvec2,yvec2,array2,lim1,lim2,title1,title2,save,field)</code></pre><p>Made a subplot in a heatmap form, using two different data (array1 and array2) with a defined colorbar scale (lim1 and lim2), their x and y coordinates (xvec1,yvec1 and xvec2,yvec2) a title for each plot (title1 and title 2), if the plot need to be saved (save) and where.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.ifdiff-NTuple{8, Any}" href="#Graphic.ifdiff-NTuple{8, Any}"><code>Graphic.ifdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifdiff(spectratokeep,array1,reconstructed_array,velocity_vector,datadim,titl,nbrow,nbcol)</code></pre><p>Plot the spectra associate with absolute differences in moment calculation (N moment order or CV) higher than a threshold between two data cube. Plot also the differences of the spectra. Array<em>moment and reconstructed</em>moment are two 2D arrays, while array1 and reconstructed_array are 3D data cube (PPV).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.ifdiff_cvmap-NTuple{7, Any}" href="#Graphic.ifdiff_cvmap-NTuple{7, Any}"><code>Graphic.ifdiff_cvmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifdiff_cvmap(cvmap,specdiff_map,xvec,yvec,lim1,lim2,titl)</code></pre><p>Add the specdiff<em>map on the plot of the cvmap . Specdiff</em>map can be a map where each pixel missing is a spectrq giving a difference in the CV calculation &gt; to a threshold, qnd the others pixels are equal to 0.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.meanpc-Tuple{Any, Any, Int64, Any, Any, String, String, Bool, String, Bool}" href="#Graphic.meanpc-Tuple{Any, Any, Int64, Any, Any, String, String, Bool, String, Bool}"><code>Graphic.meanpc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meanpc</code></pre><p>Plot two images in one plot : the first is the mean of all the spectrums of a data (using directly the rawdat, will be meaned in the function), the second is the data reconstructed with N PC (npc) obtained by a pca method on these data, using M which is a PCA object type introduced in MultivariateStats package. Need the scales of the color bars (scale1 and scale2), the titles of each plot (title1 and title2), a boolean to know if the plot need to be saved (save), the name of the save if needed (filename), and if the plots needs to be display. Arr can be 2D array (PV) or a 3D array (PPV).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.mom_conv-Tuple{Any, Any, Any, Any, Any, Int64, Any, Any, Any}" href="#Graphic.mom_conv-Tuple{Any, Any, Any, Any, Any, Int64, Any, Any, Any}"><code>Graphic.mom_conv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mom_conv(momarray,array_specavr,velocity_vector,pcnumb,momentorder,nbrow,nbcol,velocity_range)</code></pre><p>Same as the function moment_byintegration, but all plotted in different subplot in the same file. Pcnumb is a vector with all PC number you work with. Momentorder should be equal to the moment number you want to plot (used for the title).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.moment_byintegration-NTuple{4, Any}" href="#Graphic.moment_byintegration-NTuple{4, Any}"><code>Graphic.moment_byintegration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_byintegration(momarray,pcnumb,velocity_vector,momentorder)</code></pre><p>Plot the 3rd or 4th moment order of the differences of integrated by sections spectras between original data (without PCA) and reconstructed data with PCA. Pcnumb is a vector with all PC number you work with. Momentorder should be equal to the moment number you want to plot (used for the title).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.moment_multiplepc-NTuple{7, Any}" href="#Graphic.moment_multiplepc-NTuple{7, Any}"><code>Graphic.moment_multiplepc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_multiplepc(moment_multiplepc,pcnumb,nbrow,nbcol,titl,limx,limy;disp=false)</code></pre><p>Display scatter subplots comparing moment maps (N moment order or CV) obtain with different number of PC. NPC is compared with (N-1)PC. A linear function y=x is also plotted. Moment_multiplepc is a 3D array where the third dimension gives different maps calculated with a number of PC different.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.moment_multiplepc_withraw-NTuple{6, Any}" href="#Graphic.moment_multiplepc_withraw-NTuple{6, Any}"><code>Graphic.moment_multiplepc_withraw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_multiplepc_withraw(moment_multiplepc,pcnumb,array1,nbrow,nbcol,titl)</code></pre><p>Same as moment_multiplepc but compare each moment maps obtain with different number of PC with the original data (without PC). A linear function y=x is also plotted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.moment_specific_canals-Tuple{Any, Any, Any}" href="#Graphic.moment_specific_canals-Tuple{Any, Any, Any}"><code>Graphic.moment_specific_canals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_specific_canals(moment_pca,moment_nopca,data_name,pcmax)</code></pre><p>Plot a file with 4 subplots, each showing a moment calculation on the mean intensity of specific canals (generally associated with noise). &#39;moment<em>pca&#39; are the moments calculated on data reconstructed from PCA, and &#39;moment</em>nopca&#39; the moments calculated on the original data set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.pcacompwo-NTuple{4, Any}" href="#Graphic.pcacompwo-NTuple{4, Any}"><code>Graphic.pcacompwo</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.pixels_averaged_spectrum-Tuple{Any, Any, Any, Any, Any, Tuple, Any, Any}" href="#Graphic.pixels_averaged_spectrum-Tuple{Any, Any, Any, Any, Any, Tuple, Any, Any}"><code>Graphic.pixels_averaged_spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pixels_averaged_spectrum(arr,arr2,nbrow,nbcol,titl,pixel_range::Tuple,blank,vel1)</code></pre><p>Plot the averaged spectrums of two cube arr and arr2. The average is doing on a square of (pixel<em>range)  by (pixel</em>range) pixels.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.pixels_averaged_spectrum-Tuple{Any, Any, Any, Any, Tuple, Any, Any}" href="#Graphic.pixels_averaged_spectrum-Tuple{Any, Any, Any, Any, Tuple, Any, Any}"><code>Graphic.pixels_averaged_spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pixels_averaged_spectrum(arr,nbrow,nbcol,titl,pixel_range:Tuple,blank,vel1)</code></pre><p>Plot the averaged spectrums of a data. The average is doing on a square of (pixel<em>range[1]) by (pixel</em>range[2]) pixels.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.pixels_averaged_spectrum_twodata-NTuple{9, Any}" href="#Graphic.pixels_averaged_spectrum_twodata-NTuple{9, Any}"><code>Graphic.pixels_averaged_spectrum_twodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pixels_averaged_spectrum_twodata(arr,reconstructed_array,nbrow,nbcol,titl,pixel_range,blank,vel1,vel2)</code></pre><p>Plot the averaged spectrums of two fits : the rawdata and the data reconstructed from a PCA applied to these rawdata, with two velocity vectors different. The average is doing on a square of (pixel<em>range)  by (pixel</em>range) pixels.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.ploptiwind-NTuple{5, Any}" href="#Graphic.ploptiwind-NTuple{5, Any}"><code>Graphic.ploptiwind</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.plpc-Tuple{Any, Integer, Any}" href="#Graphic.plpc-Tuple{Any, Integer, Any}"><code>Graphic.plpc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    plpc(Yt,pc)</code></pre><p>Plot some principal components (PC) of data analysed by a PCA. Yt is the transformation of the raw data into principal components.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.pratio-Tuple{Any, Bool, Any, Any}" href="#Graphic.pratio-Tuple{Any, Bool, Any, Any}"><code>Graphic.pratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pratio(M::PCA,ylog::Bool,pc,titl)</code></pre><p>Plot the explained percentage of the data per principal component. If ylog is True, the yaxis will be plotted in log. Pc arguments are used to name the plot.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.region_spectrum-Tuple{}" href="#Graphic.region_spectrum-Tuple{}"><code>Graphic.region_spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">region_spectrum</code></pre><p>Plot spectra from a specific region</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.region_spectrum_twodata-NTuple{7, Any}" href="#Graphic.region_spectrum_twodata-NTuple{7, Any}"><code>Graphic.region_spectrum_twodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">region_spectrum_twodata</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.sci_not-Tuple{Any, Any}" href="#Graphic.sci_not-Tuple{Any, Any}"><code>Graphic.sci_not</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sci_not(x,ndec)</code></pre><p>Used to transform axis x labelling in scientific notation with ndec the number of decimals.</p></div></section></article><h1 id="Function-for-fBms-data-based"><a class="docs-heading-anchor" href="#Function-for-fBms-data-based">Function for fBms data based</a><a id="Function-for-fBms-data-based-1"></a><a class="docs-heading-anchor-permalink" href="#Function-for-fBms-data-based" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Functionforfbm.fbm2D-Tuple{Any, Any}" href="#Functionforfbm.fbm2D-Tuple{Any, Any}"><code>Functionforfbm.fbm2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbm2D(imsize,powerlaw ; disp = false)</code></pre><p>Construct a 2D fbm map of size imsize*imsize, following a power spectrum law equal to powerlaw. Can plot the map (disp = true).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforfbm.power_spectra-Tuple{Any, Any, Any}" href="#Functionforfbm.power_spectra-Tuple{Any, Any, Any}"><code>Functionforfbm.power_spectra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">power_spectra(arr,karr,imsize ; fitted=true)</code></pre><p>Compute the power spectrum of arr, print and plot it. karr is the frequencies array (pixel^-1). Also add a powerlaw fit by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforfbm.ppv_from_fbm-NTuple{6, Any}" href="#Functionforfbm.ppv_from_fbm-NTuple{6, Any}"><code>Functionforfbm.ppv_from_fbm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ppv_from_fbm(imsize,powerlaw,xarray,sig,stdev,tmax)</code></pre><p>Compute a ppv cube, with two gaussian components centered on the values obtained in 2D fbm maps minus the mean of the xarray (== velocity array). A noise with a standard deviation of stdev is added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforfbm.ppv_from_fbm2-NTuple{7, Any}" href="#Functionforfbm.ppv_from_fbm2-NTuple{7, Any}"><code>Functionforfbm.ppv_from_fbm2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ppv_from_fbm2(imsize,powerlaw,xarray,sig,stdev,tmax)</code></pre><p>Compute a ppv cube, with one gaussian components centered on the values obtained in 2D fbm maps minus the mean of the xarray (== velocity array). A noise with a standard deviation of stdev is added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Functionforfbm.ppv_from_fbm4-NTuple{10, Any}" href="#Functionforfbm.ppv_from_fbm4-NTuple{10, Any}"><code>Functionforfbm.ppv_from_fbm4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ppv_from_fbm4(imsize,powerlaw,xarray,sig,stdev,tmax)</code></pre><p>Compute a ppv cube, with 4 gaussian components of maxima equal to the values obtained in 2D fbm maps minus the mean of the xarray (== velocity array). A noise with a standard deviation of stdev is added. Xarray is the velocity axis wanted (write it as : -20:01:20 for example) xinc is an array (3 of size) given the increments for each components. sig is an array (3 of size) given the dispersions. A random value will also be added.</p></div></section></article><h1 id="Functions-for-Data-Analysis"><a class="docs-heading-anchor" href="#Functions-for-Data-Analysis">Functions for Data Analysis</a><a id="Functions-for-Data-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-Data-Analysis" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.calcmetric-NTuple{5, Any}" href="#Data_analysis.calcmetric-NTuple{5, Any}"><code>Data_analysis.calcmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcmetric(mom1,mom2,mom3,mom4,dv)</code></pre><p>Calculate the following metric on each values of mom1,2,3 and 4: sqrt((mom1/dv)<strong>2+(mom2/dv)</strong>2+(mom3)<strong>2+(mom4-3)</strong>2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.find_indices-Tuple{Any, Any}" href="#Data_analysis.find_indices-Tuple{Any, Any}"><code>Data_analysis.find_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_indices(specdiff,arra ; dims = size(arra))</code></pre><p>Return an array of the same dimension than arra where the indices in specdiff are equal to 1000, and others indices are equal to 0. Dims indicates the dimensions of the returned array (by default same as in input). Use this if some dimensions should not be used.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.find_threshold-Tuple{Any, Any, Any}" href="#Data_analysis.find_threshold-Tuple{Any, Any, Any}"><code>Data_analysis.find_threshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_threshold(array1,array2,thresh)</code></pre><p>Return an array with each value being the index where abs(array1[indice]-array2[indice]) is greater than a threshold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.fourmoments-Tuple{Any}" href="#Data_analysis.fourmoments-Tuple{Any}"><code>Data_analysis.fourmoments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourmoments(cube;dim=2)</code></pre><p>Compute the first four moments order of a given cube of dimension &#39;dim&#39;. If 2D PV cube, will compute the moments on each row. Return the four moments. They are Vector of dimension=size(cube)[1]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.generate_gaussian-Tuple{Any, Any, Any}" href="#Data_analysis.generate_gaussian-Tuple{Any, Any, Any}"><code>Data_analysis.generate_gaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_gaussian(xarray,mu,sig)</code></pre><p>Produce a gaussian and a normalized gaussian, following mu and sigma.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.integration_bysection-NTuple{4, Any}" href="#Data_analysis.integration_bysection-NTuple{4, Any}"><code>Data_analysis.integration_bysection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integration_bysection(data2D,integration_range,datadim,increment)</code></pre><p>Compute an integration of spectra with a given increment, for each spectra in a map. Return an array with the first dimension giving a different spectra, and the second dimension giving the integration sections.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.rms_analytic-Tuple{Any, Any, Any}" href="#Data_analysis.rms_analytic-Tuple{Any, Any, Any}"><code>Data_analysis.rms_analytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rms_analytic(yarr,rms,xarr)</code></pre><p>Return the uncertainty of the first moment order in velocity, and some part of the analytical expression. Yarr represents the emission part of the data, xarr the velocity vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.rms_analytic_field-Tuple{Any, Any, Any}" href="#Data_analysis.rms_analytic_field-Tuple{Any, Any, Any}"><code>Data_analysis.rms_analytic_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rms_analytic_field(array1,xarr,noise_canals)</code></pre><p>Return the uncertainty of the first moment order in velocity of a field, and some part of the analytical expression. Xarr represents the velocity vector. Array1 is a 2D data cube, with each row a new pixel and the columns forms the spectra.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.snr-Tuple{Any, Any}" href="#Data_analysis.snr-Tuple{Any, Any}"><code>Data_analysis.snr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snr(yarr,noise_canals)

Return the SNR of a signal (spectra for example). yarr have to be a vector.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Data_analysis.snr_allfield-Tuple{Any, Any}" href="#Data_analysis.snr_allfield-Tuple{Any, Any}"><code>Data_analysis.snr_allfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snr_allfield(arr,noise_canals)</code></pre><p>Return the mean of the SNR calculated on several spectra. Arr can be 2D (PV) or 3D (PPV) but will be faster if 2D. Better to avoid missing values in your data.</p></div></section></article><h1 id="WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations"><a class="docs-heading-anchor" href="#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations">WORK IN PROGRESS : Function for Structure functions computations</a><a id="WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations-1"></a><a class="docs-heading-anchor-permalink" href="#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Structure_fct.construct_fctstruct!-Tuple{Any, Any, Any, Any, Tuple{Int64, Int64}, Any, Any}" href="#Structure_fct.construct_fctstruct!-Tuple{Any, Any, Any, Any, Tuple{Int64, Int64}, Any, Any}"><code>Structure_fct.construct_fctstruct!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_fctstruct!</code></pre><p>Construct a matrix with the values of the structure functions at every given lag and orders (lag in columns and orders in lines). Need a preallocated array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Structure_fct.construct_fctstruct-Tuple{Any, Any, Any, Any, Tuple{Int64, Int64}, Any}" href="#Structure_fct.construct_fctstruct-Tuple{Any, Any, Any, Any, Tuple{Int64, Int64}, Any}"><code>Structure_fct.construct_fctstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_fctstruct</code></pre><p>Construct a matrix with the values of the structure functions at every given lag and orders (lag in lines and orders in columns).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Structure_fct.fct_struct-NTuple{6, Any}" href="#Structure_fct.fct_struct-NTuple{6, Any}"><code>Structure_fct.fct_struct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fct_struct(data,datapdf,order,bin)</code></pre><p>Compute the structure function of a data at a specific order.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Structure_fct.fit_fctstruct-Tuple{Any, Any, Any}" href="#Structure_fct.fit_fctstruct-Tuple{Any, Any, Any}"><code>Structure_fct.fit_fctstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_fctstruct(xdata,ydata,y0,confidinterv ; confinterv=true)</code></pre><p>Fit the model ydata=A*(xdata)^B. Can return the confidence interval too of the model. Return in first B, then A.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Structure_fct.pdf_normed-Tuple{Any, Any, Tuple, Any}" href="#Structure_fct.pdf_normed-Tuple{Any, Any, Tuple, Any}"><code>Structure_fct.pdf_normed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pdf_normed(data,bin,bound::Tuple)</code></pre><p>Compute the PDF of the data given, and normalize it by centered at 0 mean, a standard deviation of unity and an area=1.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Structure_fct.xhi_fct_p-NTuple{4, Any}" href="#Structure_fct.xhi_fct_p-NTuple{4, Any}"><code>Structure_fct.xhi_fct_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xhi_fct_p(pvec,struct_lag,lagvec,y0,confidinterv)</code></pre><p>Fit the model y=A*(x)^B for multiple order and lag of structure functions.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Others.html">« Functions used by Unveil and more</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 30 May 2023 17:44">Tuesday 30 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
