<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Detailed API · Unveil.jl Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="Quickguide.html">Unveil.jl Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="Quickguide.html">Quick guide</a></li><li><a class="tocitem" href="Unveil.html">Main functions of Unveil</a></li><li><a class="tocitem" href="Others.html">Functions used by Unveil</a></li><li class="is-active"><a class="tocitem" href="Api.html">Detailed API</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Unveil"><span>Unveil</span></a></li><li class="toplevel"><a class="tocitem" href="#Data_preparation"><span>Data_preparation</span></a></li><li class="toplevel"><a class="tocitem" href="#PCA"><span>PCA</span></a></li><li class="toplevel"><a class="tocitem" href="#SWO"><span>SWO</span></a></li><li class="toplevel"><a class="tocitem" href="#CVI"><span>CVI</span></a></li><li class="toplevel"><a class="tocitem" href="#Graphical-representations"><span>Graphical representations</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions-for-Data-Analysis"><span>Functions for Data Analysis</span></a></li><li class="toplevel"><a class="tocitem" href="#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations"><span>WORK IN PROGRESS : Function for Structure functions computations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Api.html">Detailed API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Api.html">Detailed API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/Api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h1><h1 id="Unveil"><a class="docs-heading-anchor" href="#Unveil">Unveil</a><a id="Unveil-1"></a><a class="docs-heading-anchor-permalink" href="#Unveil" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Unveil.combinecv-Tuple{}" href="#Unveil.combinecv-Tuple{}"><code>Unveil.combinecv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WORK IN PROGRESS Combine multiple CV maps into one cube.  Use this script in a julia terminal with :     julia&gt;Unveil.combinecv()</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.compmethod_stcfct-Tuple{Any}" href="#Unveil.compmethod_stcfct-Tuple{Any}"><code>Unveil.compmethod_stcfct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Comparing PCA and SWO method by printing exponant of the structure functions with the order on the same figure</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.convpca-Tuple{Any}" href="#Unveil.convpca-Tuple{Any}"><code>Unveil.convpca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convpca(VARFILEPATH)</code></pre><p>Produce calculations to find the PCA convergence criteria based on the matrix projection from PCA. No PCA reconstructed cube will be saved. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/convpca.txt&#39;).</p><p>OUTPUTS : A plots with every moments of the projection matrix + the metric (see the doc). Also add a .dat file with moments, metric and number of PC used for each.</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.convpca(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.cv-Tuple{Any}" href="#Unveil.cv-Tuple{Any}"><code>Unveil.cv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv(VARFILEPATH)</code></pre><p>Calculate the CV from a cube given in input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/cv.txt&#39;).</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.cv(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.cvcvi-Tuple{Any}" href="#Unveil.cvcvi-Tuple{Any}"><code>Unveil.cvcvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvcvi(VARFILEPATH)</code></pre><p>Calculate the CV and CVI from a cube given in input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/cvcvi.txt&#39;).</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.cvcvi(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.cvi-Tuple{Any}" href="#Unveil.cvi-Tuple{Any}"><code>Unveil.cvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cvi(VARFILEPATH)</code></pre><p>Calculate the CVI from a CV map. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/cvi.txt&#39;). </p><p>INPUT : path to the variable &#39;.txt&#39; file OUTPUTS : Save the CV fits, </p><p>Use this script in a julia terminal with :     julia&gt;Unveil.cvi(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.multipca-Tuple{Any}" href="#Unveil.multipca-Tuple{Any}"><code>Unveil.multipca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multipca(VARFILEPATH)</code></pre><p>Use multiple PCA processes on a cube and with multiple numbers of PCs given as input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/multipca.txt&#39;).</p><p>OUTPUTS : One file per cube reconstructed with one of the number of PC given as an input.</p><p>Use this script in a julia terminal with :     julia&gt;Unveil.multipca(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.pca-Tuple{Any}" href="#Unveil.pca-Tuple{Any}"><code>Unveil.pca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pca(VARFILEPATH)</code></pre><p>Use a PCA (Principal Component Analysis) process on a cube and with N PCs given as input. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/pca.txt&#39;). </p><p>INPUTS : path to the variable &#39;.txt&#39; file OUTPUTS : save a cube reconstructed by the number of PC asked in the &#39;.txt&#39; file</p><p>Use this function in a julia terminal with :     julia&gt; Unveil.pca(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.structure_functions-Tuple{Any}" href="#Unveil.structure_functions-Tuple{Any}"><code>Unveil.structure_functions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">structure_functions(VARFILEPATH)</code></pre><p>Compute the structure functions <span>$S_p(l)$</span> of a cvi cube (following definition in Kritsuk+2007). A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/structure_functions.txt&#39;). The cube given as input should be a CVI (use function <strong>Unveil.cvi</strong> if needed). Prefer a cube with rotations of every lags than azimutal average, like that : (Pixel positions,angles,lag). </p><p>OUTPUTS : One figure with <span>$S_p(l)$</span> vs <span>$S_3(l)$</span>, same with fit, and exponants of <span>$S_p(l)$</span> function of p. Also a <em>.dat</em> file with values of the exponants. Use this function in a julia terminal with :     julia&gt; Unveil.structure_functions(VARFILEPATH)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Unveil.swo-Tuple{Any}" href="#Unveil.swo-Tuple{Any}"><code>Unveil.swo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swo(VARFILEPATH)</code></pre><p>Use a SWO (Spectral Window Optimisation) process on a cube. A &#39;.txt&#39; file should be used accordingly as an input (see models inside folders &#39;/varfiles/swo.txt&#39;).</p><p>Use this function in a julia terminal with :     julia&gt; Unveil.swo(VARFILEPATH)</p></div></section></article><h1 id="Data_preparation"><a class="docs-heading-anchor" href="#Data_preparation">Data_preparation</a><a id="Data_preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data_preparation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Dataprep.addblank-NTuple{4, Any}" href="#Dataprep.addblank-NTuple{4, Any}"><code>Dataprep.addblank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addblank(data,missing_arr,blank,data_dimension)</code></pre><p>Reconstruct a data with missing values after they where deleted. Usually deleted in order to compute a PCA. Can reconstruct 3D cubes (e.g. PPV) as well as 2D maps (PP). In the first case, the input missing<em>arr should be in 2D, while in the second case it should be in 1D. The input missing</em>arr is produces with the function Data<em>preparation.pca</em>prep. The input data should be a 1D vector. Data_dimension has to be equal to the dimension you want to obtain.      To reproduce a 3D cube, it should have blank values at the exact same positions across the 3rd dimension. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.blank_equal-Tuple{Any, Any, Any}" href="#Dataprep.blank_equal-Tuple{Any, Any, Any}"><code>Dataprep.blank_equal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blank_equal(array,oldvalue,newvalue)</code></pre><p>Change the values equals to a value by another one in an array. This is useful if change of blanking is desired. You have to use the function &quot;replace_nantoblank&quot; if the old value is NaN.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.blank_inf-Tuple{Any, Any, Any}" href="#Dataprep.blank_inf-Tuple{Any, Any, Any}"><code>Dataprep.blank_inf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blank_inf(array,oldvalue,newvalue)</code></pre><p>Change the values tinier than an old value to a new value in an array. This is useful if a change of blanking is desired</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.boolmatrix_missing-Tuple{Any}" href="#Dataprep.boolmatrix_missing-Tuple{Any}"><code>Dataprep.boolmatrix_missing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boolmatrix_missing(array)</code></pre><p>Return a 1D and a 2D boolean matrices indicating the indexes of missing values in array. Array should be a 2 dimension data (pixels*spectra for example)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.delete_allnotvalue-Tuple{Any, Any}" href="#Dataprep.delete_allnotvalue-Tuple{Any, Any}"><code>Dataprep.delete_allnotvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_allnotvalue(data,blank)</code></pre><p>Delete from data all value which are not a valid value, e.g. missing, NaN and blank.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.deletemissing-Tuple{Any, Any}" href="#Dataprep.deletemissing-Tuple{Any, Any}"><code>Dataprep.deletemissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deletemissing(data,missing1D)</code></pre><p>Delete all rows where there is at least one missing value using a boolean vector of the missing values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.directory_prep-Tuple{Any}" href="#Dataprep.directory_prep-Tuple{Any}"><code>Dataprep.directory_prep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">directory_prep(PATHTOSAVE::String)</code></pre><p>Construct a new directory to save plots of the convergence criteria (Convergence_Criteria) process and another to save the fits (Data).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.pca_prep-Tuple{Any, Any}" href="#Dataprep.pca_prep-Tuple{Any, Any}"><code>Dataprep.pca_prep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pca_prep(arr,arraydimension)</code></pre><p>Prepare data (given in 2D (pv) or 3D (ppv)) in order to conduct PCA on them by deleting missing values and reshape in 2D.</p><p>Will also check if any missing value still exist in the data, showing that the data are not regularly blanked. Return data in 2 dimensions without missing value, a 1D boolean matrix to check if any missing value still exist in the data (if 0 element then no missing value) and a 2D matrix with booleans corresponding to missing values in the dataset (used to reconstruct the data with the missing values).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.permcolrow-Tuple{Any}" href="#Dataprep.permcolrow-Tuple{Any}"><code>Dataprep.permcolrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permcolrow(arr)</code></pre><p>Return the array with the first and second dimensions permuted. 2D and 3D arrays accepted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.read_dat-Tuple{Any}" href="#Dataprep.read_dat-Tuple{Any}"><code>Dataprep.read_dat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_dat(DATFILEPATH ; com=&#39;#&#39;)</code></pre><p>Return values of the .dat file given as input. By default, will consider as comment rows starting with a #. Can be changed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.read_dim-Tuple{Any}" href="#Dataprep.read_dim-Tuple{Any}"><code>Dataprep.read_dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_dim(arr)</code></pre><p>Return a vector with dimensions of the data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.read_fits_cvi-Tuple{Any}" href="#Dataprep.read_fits_cvi-Tuple{Any}"><code>Dataprep.read_fits_cvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_cvi(path ; check = true)</code></pre><p>Return the cube, its dimension and its header. Use to read CVI cube, with this order : Pixel position, Rotation, LAG.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.read_fits_pp-Tuple{Any}" href="#Dataprep.read_fits_pp-Tuple{Any}"><code>Dataprep.read_fits_pp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_pp(path)</code></pre><p>Read a 2D fits (pixel*pixel). Return values (matrix), header and dimensions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.read_fits_ppv-Tuple{Any, Any}" href="#Dataprep.read_fits_ppv-Tuple{Any, Any}"><code>Dataprep.read_fits_ppv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_fits_ppv(path,vel_units ; check = true)</code></pre><p>Read data of a PPV fits from its path, test if the fits is conform, then return : [1] Data in an array [2] Range of velocity in an array (in km/s) [3] Dimensions of the data (one vector with each element a dimension) [4] The velocity resolution (in km/s) [5] The header of the fits If the header does not contain any third dimension indication, the function will still return the data, the dimension and the header. Velocities need to be in the third dimension. This function conduct a sanity check by default. Give check = false if you don&#39;t want the test being conducted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.read_var_files-Tuple{Any}" href="#Dataprep.read_var_files-Tuple{Any}"><code>Dataprep.read_var_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_var_files(varfile_path)</code></pre><p>A function to read and import values of a variable files. The variable files can be anywhere in the machine, but preferentially localised in the &quot;var_file&quot; folders.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.regular_blanking-Tuple{Any}" href="#Dataprep.regular_blanking-Tuple{Any}"><code>Dataprep.regular_blanking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regular_blanking(data)</code></pre><p>Check if the data of a fits file contains any irregular blanking e.g. a spectra with one blanking value (or more, but less than the spectra size).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.replace_blanktomissing-Tuple{Any, Any}" href="#Dataprep.replace_blanktomissing-Tuple{Any, Any}"><code>Dataprep.replace_blanktomissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_blanktomissing(arr,blanktomissing)</code></pre><p>Replace specific values (blanktomissing, generally blank value) by missing value in an array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.replace_inf_in_nan-Tuple{Any}" href="#Dataprep.replace_inf_in_nan-Tuple{Any}"><code>Dataprep.replace_inf_in_nan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_inf_in_nan(arr)</code></pre><p>Replace the Inf values by NaN values. Useful when searching for max and min values in the array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.replace_missingtoblank-Tuple{Any, Any}" href="#Dataprep.replace_missingtoblank-Tuple{Any, Any}"><code>Dataprep.replace_missingtoblank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_missingtoblank(arr,missingtoblank)</code></pre><p>Replace missing values by a &#39;missingtoblank&#39; value in an array (generally a blank value).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.replace_nantoblank-Tuple{Any, Any}" href="#Dataprep.replace_nantoblank-Tuple{Any, Any}"><code>Dataprep.replace_nantoblank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_nantoblank(data,blank)</code></pre><p>Replace the NaN values in an array by a new blank value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.replace_nantomissing-Tuple{Any}" href="#Dataprep.replace_nantomissing-Tuple{Any}"><code>Dataprep.replace_nantomissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_nantomissing(data)</code></pre><p>Replace the NaN values in an array by missing value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.replace_nosignal-NTuple{5, Any}" href="#Dataprep.replace_nosignal-NTuple{5, Any}"><code>Dataprep.replace_nosignal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function replace_nosignal(cube,DATADIMENSION,VELOCITYVECTOR,BLANK,SIGMAMAP)</code></pre><p>Replace spectra without signal by blank value. We recover the spectra without signal by compute the intensity integration of each of them. If it is less than 2 times the dispersion of the noise, then it is blanked. SIGMAMAP is the 2D map of each rms noise of your cube ; use Data<em>analysis.rms</em>cube(cube,NOISECAN)[1] to compute it.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.write_dat-Tuple{Any, Any, Any}" href="#Dataprep.write_dat-Tuple{Any, Any, Any}"><code>Dataprep.write_dat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>write_dat(matrix,PATHTOSAVE,NAME ; more=[&quot;&quot;], overwrite=false)</p><p>Write matrix in a .dat file. Each column of the matrix is writen as new column in the file. Delimiters are spaces by default. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true. If want to add more entries on the header of the dat, use the option &#39;more&#39;. Will be added as commentaries with a # at the begining of the line.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dataprep.write_fits-Tuple{String, String, String, Any, Any, Any}" href="#Dataprep.write_fits-Tuple{String, String, String, Any, Any, Any}"><code>Dataprep.write_fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_fits(fitstocopy::String,newname::String,pathtosave::String,datatosave,datadim,blank ; finished=true)</code></pre><p>Create a fits with its own header based on &#39;fitstocopy&#39;, and with the name &#39;newfits&#39;. DO NOT ADD THE EXTENSION (e.g &quot;.fits&quot;) FOR THE NAME OF THE NEWFITS). Need to give the blanking value. The fits can be constructed by data with two dimensions or three dimensions. Variable &#39;finished&#39; is by default true, so the function will by default close the new fits file at the end of the execution of this function. If &#39;finished&#39; is false, the function will not close the fits file, allowing it to be modified again in another function (create<em>cvi</em>fits for example). If want to add more entries on the header, use the option &#39;more&#39;. Alternate between the name printed in the header and the value. Example, if want to add an entry for &#39;imsize&#39; equals to 50, and an entry for &#39;powerlaw&#39; equals to -3, write : more=[&quot;imsize&quot;,&quot;50&quot;,&quot;powerlaw&quot;,&quot;-3&quot;]. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true.</p></div></section></article><h1 id="PCA"><a class="docs-heading-anchor" href="#PCA">PCA</a><a id="PCA-1"></a><a class="docs-heading-anchor-permalink" href="#PCA" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PCA.pca-Tuple{Any, Integer, String}" href="#PCA.pca-Tuple{Any, Integer, String}"><code>PCA.pca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca(data2D,pc::Integer,path::String ; percent=1.0)</code></pre><p>Produce a Principal Component Analysis on a data, using &#39;pc&#39; number of principal component. &#39;percent&#39; gives the wanted percentage of variance reconstructed (default=1). &#39;path&#39; is the path where results will be saved (in &#39;bin&#39; temporary files, named as mmap<em>Yt.bin, mmap</em>Mproj.bin and mmap<em>Mmean.bin) Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the path to the projections of the data2D on the PC axis, the mean of these projections, the path to the matrix composed of the principal components in columns and the percentage of explained variance. These results will allow to reconstruct the cube with a given number of PC (using pca</em>nomorecalc).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PCA.pca-Tuple{Any, Integer}" href="#PCA.pca-Tuple{Any, Integer}"><code>PCA.pca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca(data2D,pc::Integer ; percent=1.0)</code></pre><p>Produce a Principal Component Analysis on a data, using &#39;pc&#39; number of principal component. &#39;percent&#39; gives the wanted percentage of variance reconstructed (default=1).  Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the pca fit M (a type created by the MultivariateStats package), the matrix composed of the principal components in columns, the percentage of explained variance and the data reconstructed with &#39;pc&#39; number of principal component. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PCA.pca_nomorecalc-NTuple{5, Any}" href="#PCA.pca_nomorecalc-NTuple{5, Any}"><code>PCA.pca_nomorecalc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim)</code></pre><p>Reconstruct data with a certain number of PC, without redo all of the PCA calculation. Necessary to do a first pca calculation to run this one, because needed M (a new type related to PCA constructed by MultivariateStats package) and Yt (matrix with each column a PC). Datadim should be a tuple with two values (PV cube, 2D) or three (PPV cube, 3D).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PCA.pca_nomorecalc-Tuple{String, String, String, Any, Any, Any}" href="#PCA.pca_nomorecalc-Tuple{String, String, String, Any, Any, Any}"><code>PCA.pca_nomorecalc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    pca_nomorecalc(Mproj_path::String,Yt_path::String,Mmean_path::String,pcfirst,pclast,datadim)</code></pre><p>Same as pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim) but using here the path to the temporary files containing the informations (M and Yt). To be used after pca(data2D,pc::Integer,path::String ; percent=1.0) in order to produce a reconstructed cube.</p></div></section></article><h1 id="SWO"><a class="docs-heading-anchor" href="#SWO">SWO</a><a id="SWO-1"></a><a class="docs-heading-anchor-permalink" href="#SWO" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SWO.bestsnr-NTuple{4, Any}" href="#SWO.bestsnr-NTuple{4, Any}"><code>SWO.bestsnr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bestsnr(cubesource,DATADIMENSION_NOMISSING,VELOCITYVECTOR,NOISECAN)</code></pre><p>Method SWO (Spectral Window Optimisation). For each spectra of the <em>cubesource</em>, look for the maximum SNR given by :</p><p class="math-container">\[SNR(v_\text{i})=\frac{\sum_{\text{i}=1}^\text{m}T_\text{i}}{\sqrt{m\sigma_{1:m}}}\]</p><p>In this equation, <span>$T_\text{i}$</span> is the intensity at velocity channel <span>$v_\text{i}$</span>, and <span>$\sigma_{1:m}$</span> the dispersion computed between velocity channels 1 to m. The SNR is computed in increasing velocity channels, then in decreasing velocity channels. Each maxima of these two computations will give one window limit containing the emission.</p><p>INPUT : <em>cubesource</em>, the cube whom you want to compute the SWO. It should be in 2D (PxP,V), as <em>DATADIMENSION_NOMISSING</em>, which gives the total dimensions of the cube. <em>VELOCITYVECTOR</em> is the velocity vector, computed and given as output of the function <strong>Dataprep.read_fits_ppv</strong>. <em>NOISECAN</em> are some of the velocity channels of the cube where there is only noise. Used to compute the dispersion of the noise of <em>cubesource</em>.</p><p>OUTPUT : [1] Cubesource with SWO mask applied (inside mask windows are equal to cubesource, outside is 0)           [2] Mask of SWO method computed on cubesource</p></div></section></article><h1 id="CVI"><a class="docs-heading-anchor" href="#CVI">CVI</a><a id="CVI-1"></a><a class="docs-heading-anchor-permalink" href="#CVI" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CVI.construct_cvimap!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}}" href="#CVI.construct_cvimap!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}}"><code>CVI.construct_cvimap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap!(xyarr,Lag::Int64,mapdim,cvi_averaged::Array{Union{Missing, Float64}},cvi_allangle::Array{Union{Missing,Float64},3}; diff=&quot;relative&quot;,keepmissing=true)</code></pre><p>Will construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cvi<em>averaged), and another for the cvi calculated with all angle and lag (cvi</em>allangle). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.construct_cvimap!-Tuple{Any, Vector{Int64}, Any, Any, Matrix{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}, Array{Union{Missing, Float64}, 3}}" href="#CVI.construct_cvimap!-Tuple{Any, Vector{Int64}, Any, Any, Matrix{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}, Array{Union{Missing, Float64}, 3}}"><code>CVI.construct_cvimap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap!(xyarr,Lag::Vector{Int64},mapdim,cvi_averaged_alllag::Array{Union{Missing, Float64},2},cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle::Array{Union{Missing,Float64},3}; diff=&quot;relative&quot;,keepmissing=true)</code></pre><p>Will construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cvimean), and another for the cvi calculated with all angle and lag (cvi<em>allangle</em>alllag). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.construct_cvimap-Tuple{Any, Int64, Any}" href="#CVI.construct_cvimap-Tuple{Any, Int64, Any}"><code>CVI.construct_cvimap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap(cvmap,Lag::Int64,mapdim; diff=&quot;relative&quot;,keepmissing=true)</code></pre><p>Same as construct_cvimap if Lag is a Int64 of one lag. Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.construct_cvimap-Tuple{Any, Vector{Int64}, Any}" href="#CVI.construct_cvimap-Tuple{Any, Vector{Int64}, Any}"><code>CVI.construct_cvimap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_cvimap(cvmap,Lag::Vector{Int64},mapdim; diff=&quot;relative&quot;,keepmissing=true,BLANK=-1000)</code></pre><p>Construct a Centroid Velocity Increment map based on a &#39;cvmap&#39;. The cvi map is constructed by taking the mean of all rotations of the Centroid Velocity Increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.cv_increment!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}, 3}}" href="#CVI.cv_increment!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}, 3}}"><code>CVI.cv_increment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment!(xyarr,Lag::Int64,blank,cvimap_lag::Array{Union{Missing,Float64},2})</code></pre><p>Same as (xyarr,Lag::Int64,nangle; diff=&quot;relative&quot;,periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cvi_allangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.cv_increment!-Tuple{Any, Vector{Int64}, Any, Array{Union{Missing, Float64}, 3}, Any}" href="#CVI.cv_increment!-Tuple{Any, Vector{Int64}, Any, Array{Union{Missing, Float64}, 3}, Any}"><code>CVI.cv_increment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment!(xyarr,Lag::Vector{Int64},nangle,cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle ; diff=&quot;relative&quot;,periodic=false)</code></pre><p>Same as cv<em>increment(xyarr,Lag::Vector{Int64},nangle; diff=&quot;relative&quot;,periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cvi</em>allangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle) and cvi<em>allangle</em>alllag = Array{Union{Missing,Float64},3}(undef,DataDimension[1]*DataDimension[2],nangle,size(Lag)[1])</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.cv_increment-Tuple{Any, Int64, Any, Any}" href="#CVI.cv_increment-Tuple{Any, Int64, Any, Any}"><code>CVI.cv_increment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment(xyarr,Lag::Int64,nangle; diff=&quot;relative&quot;,periodic=false)</code></pre><p>Compute the centroid velocity increment of xyarr at one Lag. Nangle is the number of angle using to compute the differences (it&#39;s a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first two dimensions equal to the size of the map, and the third dimension is the cvi computed at each angle.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.cv_increment-Tuple{Any, Vector{Int64}, Any}" href="#CVI.cv_increment-Tuple{Any, Vector{Int64}, Any}"><code>CVI.cv_increment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cv_increment(xyarr,Lag::Vector{Int64},nangle; diff=&quot;relative&quot;,periodic=false)</code></pre><p>Compute the centroid velocity increment of xyarr at multiple Lag values. Nangle is the number of angle using to compute the differences (it&#39;s a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first dimension equal to the size of the map (pixel square), the second dimension is the cvi computed at each angle, and the third dimension is for each value of Lag.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.moment_one-Tuple{Any, Any}" href="#CVI.moment_one-Tuple{Any, Any}"><code>CVI.moment_one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_one(yarr,xarr)</code></pre><p>Compute the first moment order of the array xarr weighted by yarr. Centroid = int(T*v)dv/int(T)dv</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CVI.moment_one_field-NTuple{5, Any}" href="#CVI.moment_one_field-NTuple{5, Any}"><code>CVI.moment_one_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moment_one_field(arr,velvector)</code></pre><p>Return the first moment order of all pixels in an entire field, weighted by velvector. Arr can be a 3D array (ppv) or a 2D array (pv). The function replace all missing values by </p></div></section></article><h1 id="Graphical-representations"><a class="docs-heading-anchor" href="#Graphical-representations">Graphical representations</a><a id="Graphical-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Graphical-representations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Graphic.StcFct-NTuple{4, Any}" href="#Graphic.StcFct-NTuple{4, Any}"><code>Graphic.StcFct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StcFct()</code></pre><p>Plot structure functions of orders p in function of the structure function of order 3. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.StcFctExponent-NTuple{7, Any}" href="#Graphic.StcFctExponent-NTuple{7, Any}"><code>Graphic.StcFctExponent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StcFctExponent(zeta,third_order_zeta,OrderP,xlim,ylim,labs,data_name_title,directories_name; add=false,save=true,pcfinal=0)</code></pre><p>Plot the exponent of the structure function power-law fit in function of the order p of the structure function. If add is true, the plot will be added on the actual plot. Also add a y=1/3x line on the plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphic.StcFctWithFit-NTuple{6, Any}" href="#Graphic.StcFctWithFit-NTuple{6, Any}"><code>Graphic.StcFctWithFit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StcFctWithFit()</code></pre><p>Plot structure functions of orders p in function of the structure function of order 3 with the fit used to obtain the power-law exponent. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.</p></div></section></article><h1 id="Functions-for-Data-Analysis"><a class="docs-heading-anchor" href="#Functions-for-Data-Analysis">Functions for Data Analysis</a><a id="Functions-for-Data-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-Data-Analysis" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Analysis.fourmoments-Tuple{Any}" href="#Analysis.fourmoments-Tuple{Any}"><code>Analysis.fourmoments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourmoments(cube;dim=2)</code></pre><p>Compute the first four moments order of a given cube of dimension &#39;dim&#39;. If 2D PV cube, will compute the moments on each row. Return the four moments. They are Vector of dimension=size(cube)[1]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Analysis.metricOW-NTuple{6, Any}" href="#Analysis.metricOW-NTuple{6, Any}"><code>Analysis.metricOW</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metricOW(mom1,mom2,mom3,mom4,dv,SIGMAT)</code></pre><p>Calculate the following metric on each values of mom1,2,3 and 4: sqrt((mom1)<strong>2+((mom2-SIGMAT))</strong>2+(mom3)<strong>2+(mom4-3)</strong>2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Analysis.metricPCA-NTuple{5, Any}" href="#Analysis.metricPCA-NTuple{5, Any}"><code>Analysis.metricPCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metricPCA(mom1,mom2,mom3,mom4,dv)</code></pre><p>Calculate the following metric on each values of mom1,2,3 and 4: sqrt((mom1/dv)<strong>2+(mom2/dv)</strong>2+(mom3)<strong>2+(mom4-3)</strong>2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Analysis.rms_cube-Tuple{Any, Any}" href="#Analysis.rms_cube-Tuple{Any, Any}"><code>Analysis.rms_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rms_cube(cube,can)</code></pre><p>Compute the rms on velocity canal given as input of a cube. Return a 2D map with given rms on each pixel and the averaged rms accross the map.</p></div></section></article><h1 id="WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations"><a class="docs-heading-anchor" href="#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations">WORK IN PROGRESS : Function for Structure functions computations</a><a id="WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations-1"></a><a class="docs-heading-anchor-permalink" href="#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Structure_functions.fit_fctsct-Tuple{Any, Any, Any}" href="#Structure_functions.fit_fctsct-Tuple{Any, Any, Any}"><code>Structure_functions.fit_fctsct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_fctstruct(xdata,ydata,y0,confidinterv)</code></pre><p>Fit the model ydata=A*(xdata)^B. Return in first B, then A.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Structure_functions.xhi_fct_p-Tuple{Any, Any}" href="#Structure_functions.xhi_fct_p-Tuple{Any, Any}"><code>Structure_functions.xhi_fct_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xhi_fct_p(pvec,struct_lag,y0)</code></pre><p>Fit the model y=A*(x)^B for multiple order and lag of structure functions.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Others.html">« Functions used by Unveil</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 6 July 2023 15:35">Thursday 6 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
