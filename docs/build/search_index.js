var documenterSearchIndex = {"docs":
[{"location":"Api.html#Description","page":"Detailed API","title":"Description","text":"","category":"section"},{"location":"Api.html#Unveil","page":"Detailed API","title":"Unveil","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Unveil]\nPages = [\"Unveil.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Unveil.combinecv-Tuple{}","page":"Detailed API","title":"Unveil.combinecv","text":"WORK IN PROGRESS Combine multiple CV maps into one cube.  Use this script in a julia terminal with :     julia>Unveil.combinecv()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.convpca-Tuple{}","page":"Detailed API","title":"Unveil.convpca","text":"Produce calculations to find the PCA convergence criteria based on the matrix projection from PCA. No PCA reconstructed cube will be saved.  User parameters have to be modified in file /../varfiles/cvoptiwind.txt or /../varfiles/pcaconvproj.txt if want to use it with bash script Use this script in a julia terminal with :      julia>Unveil.pcaconvproj()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.convswo-Tuple{}","page":"Detailed API","title":"Unveil.convswo","text":"Look for the best interval to integrate the spectra for the window optimisation process.  User parameters have to be modified in file /../varfiles/convoptiwind.txt   Use this script in a julia terminal with :      julia>Unveil.convoptiwind()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.cvcvi-Tuple{}","page":"Detailed API","title":"Unveil.cvcvi","text":"Calculate the CV and CVI from a cube given in input. User parameters have to be modified in file /../varfiles/cvi.txt or /../varfiles/cvi_forbash.txt if want to use it with bash script Use this script in a julia terminal with :     julia>Unveil.cvcvi()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.cvi-Tuple{}","page":"Detailed API","title":"Unveil.cvi","text":"Calculate the CV and CVI from a cube given in input. User parameters have to be modified in file /../varfiles/cvi.txt or /../varfiles/cvi_forbash.txt if want to use it with bash script     Use this script in a julia terminal with :         julia>Unveil.cvi()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.multipca-Tuple{}","page":"Detailed API","title":"Unveil.multipca","text":"Use multiple PCA processes on a cube and with multiple numbers of PCs given as input User parameters have to be modified in file /../varfiles/multipca.txt Use this script in a julia terminal with :     julia>Unveil.multipca()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.pca-Tuple{}","page":"Detailed API","title":"Unveil.pca","text":"Use a PCA (Principal Component Analysis) process on a cube and with N PCs given as input User parameters have to be modified in file /varfiles/pca.txt. Another VARFILEPATH can be given, but the structure of the file should be followed ! Use this function in a julia terminal with :     julia> Unveil.pca()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.swo-Tuple{}","page":"Detailed API","title":"Unveil.swo","text":"Use a SWO (Spectral Window Optimisation) process on a cube. User parameters have to be modified in file /varfiles/swo.txt. Another VARFILEPATH can be given as input, but the structure of the file should be followed ! Use this function in a julia terminal with :     julia> Unveil.swo()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation","page":"Detailed API","title":"Data_preparation","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Data_preparation]\nPages = [\"Data_preparation.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Data_preparation.addblank-NTuple{4, Any}","page":"Detailed API","title":"Data_preparation.addblank","text":"addblank(data,missing_arr,blank,data_dimension)\n\nReconstruct a data with missing values after they where deleted. Usually deleted in order to compute a PCA. Can reconstruct 3D cubes (e.g. PPV) as well as 2D maps (PP). In the first case, the input missingarr should be in 2D, while in the second case it should be in 1D. The input missingarr is produces with the function Datapreparation.pcaprep. The input data should be a 1D vector. Data_dimension has to be equal to the dimension you want to obtain.      To reproduce a 3D cube, it should have blank values at the exact same positions across the 3rd dimension. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.addmask-NTuple{8, Any}","page":"Detailed API","title":"Data_preparation.addmask","text":"addmask(cube,colorscale,nbmask,data_dimension,delta_xvec,delta_yvec)\n\nBlank all the pixels in the third dimension selected manually by the user (using a contour). Can do multiple mask.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.allmissing-Tuple{Any}","page":"Detailed API","title":"Data_preparation.allmissing","text":"allmissing(data)\n\nReturn true if the data contain any missing value.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.blank_equal-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_preparation.blank_equal","text":"blank_equal(array,oldvalue,newvalue)\n\nChange the values equals to a value by another one in an array. This is useful if change of blanking is desired. You have to use the function \"replace_nantoblank\" if the old value is NaN.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.blank_inf-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_preparation.blank_inf","text":"blank_inf(array,oldvalue,newvalue)\n\nChange the values tinier than an old value to a new value in an array. This is useful if a change of blanking is desired\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.blank_inf_abs-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_preparation.blank_inf_abs","text":"blank_inf_abs(array,oldvalue,newvalue)\n\nChange the values tinier than an old value (its absolute value) to a new value in an array. This is useful if a change of blanking is desired\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.blank_snr-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_preparation.blank_snr","text":"blank_snr(data2D,NoiseCan,thresh)\n\nBlank all the spectra which have a signal to noise ratio inferior than a threshold. Work on 2D data, the first dimension giving the pixel position and the second dimension the spectra referring to this position.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.blank_sup-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_preparation.blank_sup","text":"blank_sup(array,oldvalue,newvalue)\n\nChange the values bigger than an old value to a new value of an array . This is useful if a change of blanking is desired\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.boolmatrix_missing-Tuple{Any}","page":"Detailed API","title":"Data_preparation.boolmatrix_missing","text":"boolmatrix_missing(array)\n\nReturn a 1D and a 2D boolean matrices indicating the indexes of missing values in array. Array should be a 2 dimension data (pixels*spectra for example)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.clear_var-NTuple{4, Any}","page":"Detailed API","title":"Data_preparation.clear_var","text":"clear_var(var1,var2,var3,var4)\n\nReplace all variable in input by 0 to \"free\" space.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.coordtopix-NTuple{5, Any}","page":"Detailed API","title":"Data_preparation.coordtopix","text":"coordtopix(header,coord,unit,ax ; off=true)\n\nDo the conversion between physical coordinate and pixel number thanks to the header of the data. Works only for small-size fields. Need the unit of the coordinate given (arcsec,arcmin,rad,deg only) and the axis. Consider by default that the coordinate given is an offset (place at the center of the image). The values of CRVAL1... are considered in deg.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.delete_allnotvalue-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.delete_allnotvalue","text":"delete_allnotvalue(data,blank)\n\nDelete from data all value which are not a valid value, e.g. missing, NaN and blank.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.deletemissing-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.deletemissing","text":"deletemissing(data,missing1D)\n\nDelete all rows where there is at least one missing value using a boolean vector of the missing values.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.directory_prep-Tuple{Any}","page":"Detailed API","title":"Data_preparation.directory_prep","text":"directory_prep(PATHTOSAVE::String)\n\nConstruct a new directory to save plots of the convergence criteria (Convergence_Criteria) process and another to save the fits (Data).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.lookingfor_interval-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_preparation.lookingfor_interval","text":"lookingfor_interval(arr,value,sigma)\n\nReturn the array (1D) cut at [value-sigma:value+sigma]. Return also the indices of these values.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.noise_channels-Tuple{}","page":"Detailed API","title":"Data_preparation.noise_channels","text":"noise_channels()\n\nConstruct a vector with two subranges. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.pca_prep-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.pca_prep","text":"pca_prep(arr,arraydimension)\n\nPrepare data (given in 2D (pv) or 3D (ppv)) in order to conduct PCA on them by deleting missing values and reshape in 2D.\n\nWill also check if any missing value still exist in the data, showing that the data are not regularly blanked. Return data in 2 dimensions without missing value, a 1D boolean matrix to check if any missing value still exist in the data (if 0 element then no missing value) and a 2D matrix with booleans corresponding to missing values in the dataset (used to reconstruct the data with the missing values).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.permcolrow-Tuple{Any}","page":"Detailed API","title":"Data_preparation.permcolrow","text":"permcolrow(arr)\n\nReturn the array with the first and second dimensions permuted. 2D and 3D arrays accepted.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.pixtocoord-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.pixtocoord","text":"pixtocoord(header,unit)\n\nDo the conversion between pixel number and physical coordinate thanks to the header of the data. Return the X and Y coordinates in the physical coordinates you want, then the X and Y coordinate centered at the middle of the plot.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.read_dim-Tuple{Any}","page":"Detailed API","title":"Data_preparation.read_dim","text":"read_dim(arr)\n\nReturn a vector with dimensions of the data.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.read_fits_pp-Tuple{Any}","page":"Detailed API","title":"Data_preparation.read_fits_pp","text":"read_fits_pp(path)\n\nRead a 2D fits (pixel*pixel). Return values (matrix), header and dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.read_fits_ppf-Tuple{Any}","page":"Detailed API","title":"Data_preparation.read_fits_ppf","text":"read_fits_ppf(field ; path=\"none\", check = true) WIP\n\nRead data of a PPF fits from its path, test if the fits is conform, then return : [1] Data in an array [2] Range of velocity in an array (in km/s) [3] X coordinate in arcsecond [4] Y coordinate in arcsecond [5] X coordinates centered in the middle of the image [6] Y coordinates centered in the middle of the image [7] Dimensions of the data (one vector with each element a dimension) [8] The velocity resolution (in km/s) [9] The header of the fits [10] The path to the fits Make the conversion of frequency into velocity. If the header does not contain any third dimension indication, the function will still return the data, the dimension and the header. Velocities need to be in the third dimension. This function conduct a sanity check by default. Give check = false if you don't want the test being conducted.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.read_fits_ppv-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.read_fits_ppv","text":"read_fits_ppv(path,vel_units ; check = true)\n\nRead data of a PPV fits from its path, test if the fits is conform, then return : [1] Data in an array [2] Range of velocity in an array (in km/s) [3] Dimensions of the data (one vector with each element a dimension) [4] The velocity resolution (in km/s) [5] The header of the fits If the header does not contain any third dimension indication, the function will still return the data, the dimension and the header. Velocities need to be in the third dimension. This function conduct a sanity check by default. Give check = false if you don't want the test being conducted.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.read_fits_spect-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.read_fits_spect","text":"read_fits_spect(path,vel_units )\n\nRead data of a spectra PV fits from the path of the field and return : [1] an array of the data [2] an array of the range of velocity (in km/s) [3] the velocity resolution (in km/s) [4] the header of the fits [5] the file of the fits\n\nVelocities need to be in the second dimension. By default, the path of the fits is \"none\", because we usually use local path listed in the function data_path.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.read_fits_velocityvector-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.read_fits_velocityvector","text":"read_fits_velocityvector(path,vel_units)\n\nReconstruct the velocity vector of a fits file. Have to specify the units of the velocity vector of the fits.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.read_var_files-Tuple{Any}","page":"Detailed API","title":"Data_preparation.read_var_files","text":"read_var_files(varfile_path)\n\nA function to read and import values of a variable files. The variable files can be anywhere in the machine, but preferentially localised in the \"var_file\" folders.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.regular_blanking-Tuple{Any}","page":"Detailed API","title":"Data_preparation.regular_blanking","text":"regular_blanking(data)\n\nCheck if the data of a fits file contains any irregular blanking e.g. a spectra with one blanking value (or more, but less than the spectra size).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.replace_blanktomissing-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.replace_blanktomissing","text":"replace_blanktomissing(arr,blanktomissing)\n\nReplace specific values (blanktomissing, generally blank value) by missing value in an array.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.replace_inf_in_nan-Tuple{Any}","page":"Detailed API","title":"Data_preparation.replace_inf_in_nan","text":"replace_inf_in_nan(arr)\n\nReplace the Inf values by NaN values. Useful when searching for max and min values in the array.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.replace_missingtoblank-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.replace_missingtoblank","text":"replace_missingtoblank(arr,missingtoblank)\n\nReplace missing values by a 'missingtoblank' value in an array (generally a blank value).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.replace_nantoblank-Tuple{Any, Any}","page":"Detailed API","title":"Data_preparation.replace_nantoblank","text":"replace_nantoblank(data,blank)\n\nReplace the NaN values in an array by a new blank value.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.replace_nantomissing-Tuple{Any}","page":"Detailed API","title":"Data_preparation.replace_nantomissing","text":"replace_nantomissing(data)\n\nReplace the NaN values in an array by missing value.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.valid_header-Tuple{Any}","page":"Detailed API","title":"Data_preparation.valid_header","text":"    valid_header(header)\n\nCheck if the header of a fits file contains a blank, a bzero, and a bscale values.\n\nIf not, return an error.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.wait_for_key-Tuple{}","page":"Detailed API","title":"Data_preparation.wait_for_key","text":"wait_for_key(; prompt = \"Press any key\", io = stdin))\n\nPause the script until the user press a key. The text prompt can be changed.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.write_cv_fits-Tuple{String, String, String, Any, Any, Any}","page":"Detailed API","title":"Data_preparation.write_cv_fits","text":"write_cv_fits(fitstocopy::String,newname::String,data,datadim,blank ; pc=0,varpercent=100)\n\nCreate a fits file used for cv reconstructed data. Contains on its header the number of pc used (default=0), the percentage of variance explained (default=100), the lag and the angle. Need a fits to copy its header entries.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.write_cvi_fits-Tuple{Any, String, String, String, Any, Any, Any}","page":"Detailed API","title":"Data_preparation.write_cvi_fits","text":"write_cvi_fits(lag,fitstocopy::String,newname::String,data,datadim,blank; pc=0,varpercent=100)\n\nCreate a fits used for cvi map. Contains on its header the lag used to do the cvi. Possibility to add in the header the number of PC used if data reconstructed from a PCA and the percentage of variance reproduced thank's to the PCA.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.write_dat-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_preparation.write_dat","text":"write_dat(matrix,PATHTOSAVE,NAME ; more=[\"\"], overwrite=false)\n\nWrite matrix in a .dat file. Each column of the matrix is writen as new column in the file. Delimiters are spaces by default. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true. If want to add more entries on the header of the dat, use the option 'more'. Will be added as commentaries with a # at the begining of the line.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.write_fits-Tuple{String, String, String, Any, Any, Any}","page":"Detailed API","title":"Data_preparation.write_fits","text":"write_fits(fitstocopy::String,newname::String,pathtosave::String,datatosave,datadim,blank ; finished=true)\n\nCreate a fits with its own header based on 'fitstocopy', and with the name 'newfits'. DO NOT ADD THE EXTENSION (e.g \".fits\") FOR THE NAME OF THE NEWFITS). Need to give the blanking value. The fits can be constructed by data with two dimensions or three dimensions. Variable 'finished' is by default true, so the function will by default close the new fits file at the end of the execution of this function. If 'finished' is false, the function will not close the fits file, allowing it to be modified again in another function (createcvifits for example). If want to add more entries on the header, use the option 'more'. Alternate between the name printed in the header and the value. Example, if want to add an entry for 'imsize' equals to 50, and an entry for 'powerlaw' equals to -3, write : more=[\"imsize\",\"50\",\"powerlaw\",\"-3\"]. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation.write_pca_fits-Tuple{Any, Any, String, String, String, Any, Any, Any}","page":"Detailed API","title":"Data_preparation.write_pca_fits","text":"write_pca_fits(pc,varpercent,fitstocopy::String,newname::String,data,datadim,blank)\n\nCreate a fits used for pca reconstructed data. Contains on its header the number of pc used and the percentage of variance explained. Need a fits to copy its header entries.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#PCA","page":"Detailed API","title":"PCA","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Functionforpca]\nPages = [\"Functionforpca.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Functionforpca.convergence_moments_byintegration-NTuple{8, Any}","page":"Detailed API","title":"Functionforpca.convergence_moments_byintegration","text":"    convergence_moments_byintegration(data2D,integration_range,pcnumber,velocity_increment,M,Yt,datadim,velocity_vector,IM)\n\nReturn the I-th moment order of the integrated by sections spectras differences, from arrays reconstructed with N PC and arrays without PCA. Also return the new velocity vector where each value is centered on the integrated sections. The function integrate by section (the integration_range) spectra from reconstructed and non-reconstructed data, then compute the given moment order of their differences. Data should be in 2 dimensions (PV cube), and datadim should refers to the dimension of the 3D data cube (PPV). Pcnumber should be a vector with all the number of PC you want (example Vector(1:10)).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.cv_convergence-NTuple{5, Any}","page":"Detailed API","title":"Functionforpca.cv_convergence","text":"    cv_convergence(pcmax,M,Yt,velocity_vector,datadim)\n\nReturn a cube reconstructed with different number of PC, its first and its second velocity moment order. The cube considered is the one processed by PCA, that gave M and Yt as a result. The arrays in output are in 3D, where the third dimensions gives results for different number of PC used. Datadim should be the dimension of the 3D initial PPV cube. M is a PCA type, produced by the function pca. Yt is a vector or a matrix where each column gives the principal components of an observation.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.intensity_moments_specific_channels-Tuple{Any, Any, Any}","page":"Detailed API","title":"Functionforpca.intensity_moments_specific_channels","text":"    intensity_moments_specific_channels(arr_path,channels,datadim)\n\nWill compute the first, second, third and fourth, moments order of the mean of given channels in a data cube. The cube is not given as input but only the path where it is saved as a 'bin' temporary file (saving RAM). Datadim refer to the dimension of the 3D data cube (the original data cube).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.intensity_moments_specific_channels_withPCA-Tuple{Any, String, Any, Any, Any}","page":"Detailed API","title":"Functionforpca.intensity_moments_specific_channels_withPCA","text":"    intensity_moments_specific_channels_withPCA(M,Yt_path::String,pcnumber,canals,datadim)\n\nWill compute the first, second, third and fourth moments order of the mean of specific canals in the data reconstructed with different number of PC to check if they are converging. Datadim refer to the dimension of the 3D data cube (the original data cube). M is a PCA type, produced by the function pca. Yt_path is the path where Yt is saved as a 'bin' temporary fil. Yt is a vector or a matrix where each column gives the principal components of an observation. M and Yt are obtained with the function pca. Moment order can be any Int from 1 to 4. Return one 1D array.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.intensity_moments_specific_channels_withPCASVDRAND-NTuple{4, Any}","page":"Detailed API","title":"Functionforpca.intensity_moments_specific_channels_withPCASVDRAND","text":"    intensity_moments_specific_channels_withPCASVDRAND(svdobject,pcnumber,channels,p)\n\nSame as intensitymomentsspecificchannelswithPCA but using a Principal Component Analysis based on random SVD.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.multiple_moment!-NTuple{8, Any}","page":"Detailed API","title":"Functionforpca.multiple_moment!","text":"    multiple_moment!\n\nSame as multiple_moment but on pre-allocated data.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.multiple_moment-NTuple{5, Any}","page":"Detailed API","title":"Functionforpca.multiple_moment","text":"    multiple_moment(velvector,data_dimension,M,Yt,pcmax)\n\nCompute first and second velocity moment order of multiple data cube. The data cubes are reconstructed from PCA with different number of PC.  M is a PCA type, produced by the function pca. Yt is a vector or a matrix where each column gives the principal components of an observation.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.multiplepca-NTuple{4, Any}","page":"Detailed API","title":"Functionforpca.multiplepca","text":"    multiplepca(M,Yt,pcnumber,datadim)\n\nDo multiple PCA with different number of PC on the same data. Will return a 3D array, with pixel position in the first dimension, velocity in the second dimension, and the data reconstructed with a specific number of pc in the third dimension. Pcnumber should be a vector with all the number of PC you want (example Vector(1:10)).  M is a PCA type, produced by the function pca. Yt is a vector or a matrix where each column gives the principal components of an observation.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.pca-Tuple{Any, Integer, String}","page":"Detailed API","title":"Functionforpca.pca","text":"    pca(data2D,pc::Integer,path::String ; percent=1.0)\n\nProduce a Principal Component Analysis on a data, using 'pc' number of principal component. 'percent' gives the wanted percentage of variance reconstructed (default=1). 'path' is the path where results will be saved (in 'bin' temporary files, named as mmapYt.bin, mmapMproj.bin and mmapMmean.bin) Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the path to the projections of the data2D on the PC axis, the mean of these projections, the path to the matrix composed of the principal components in columns and the percentage of explained variance. These results will allow to reconstruct the cube with a given number of PC (using pcanomorecalc).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.pca-Tuple{Any, Integer}","page":"Detailed API","title":"Functionforpca.pca","text":"    pca(data2D,pc::Integer ; percent=1.0)\n\nProduce a Principal Component Analysis on a data, using 'pc' number of principal component. 'percent' gives the wanted percentage of variance reconstructed (default=1).  Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the pca fit M (a type created by the MultivariateStats package), the matrix composed of the principal components in columns, the percentage of explained variance and the data reconstructed with 'pc' number of principal component. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.pca_nomorecalc-NTuple{5, Any}","page":"Detailed API","title":"Functionforpca.pca_nomorecalc","text":"    pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim)\n\nReconstruct data with a certain number of PC, without redo all of the PCA calculation. Necessary to do a first pca calculation to run this one, because needed M (a new type related to PCA constructed by MultivariateStats package) and Yt (matrix with each column a PC). Datadim should be a tuple with two values (PV cube, 2D) or three (PPV cube, 3D).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.pca_nomorecalc-Tuple{String, String, String, Any, Any, Any}","page":"Detailed API","title":"Functionforpca.pca_nomorecalc","text":"    pca_nomorecalc(Mproj_path::String,Yt_path::String,Mmean_path::String,pcfirst,pclast,datadim)\n\nSame as pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim) but using here the path to the temporary files containing the informations (M and Yt). To be used after pca(data2D,pc::Integer,path::String ; percent=1.0) in order to produce a reconstructed cube.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforpca.variance_evolution-Tuple{Any, Any}","page":"Detailed API","title":"Functionforpca.variance_evolution","text":"    variance_evolution(M,threshold)\n\nReturn an Array with the numbers of PC explaining a percentage of the data variance tinier (or equal) than the threshold given in input.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#SWO","page":"Detailed API","title":"SWO","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Spectralwindowopti]\nPages = [\"Spectralwindowopti.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Spectralwindowopti.convoptiwind-NTuple{9, Any}","page":"Detailed API","title":"Spectralwindowopti.convoptiwind","text":"convoptiwind(cubesource,DATADIMENSION,VELOCITYVECTOR,NOISECAN,BLANK,RANGE,PATHTOSAVE)\n\nDATADIMENSION should be 2D : PV\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Spectralwindowopti.optiwind-NTuple{6, Any}","page":"Detailed API","title":"Spectralwindowopti.optiwind","text":"optiwind(cube,DATADIMENSION,VELOCITYVECTOR,NOISECAN,BLANK,RANGE)\n\nINPUT DESCRIPTION Method of window optimisation. Search for the limits of the signals in each spectrum of the cube. The cube given as input should be in 2Dimensions, with spectrum ordonnated by row. A first CV computation on each spectra should also be given as input : cvmap. Cvmap is in 1D, with each position corresponding to the spectrum of the same position in the 2D cube. The velocity vector should also be given (obtained by Datapreparation.readfits_ppv). NOISECAN corresponds to a Vector{Int64} of 2 entries, where each entry corresponds to a position in the Velocity Vector of a noise cannal : they have to englobe only noise. Used to compute the noise rms ; ESSENTIAL IN THE COMPUTATION. The last value RANGE is the size of the increment used during the computation : lower it is and longer the code will be. \n\nMETHOD  A first initialisation of a mask of same size than the input cube, with 0 everywhere. For each spectra, compute the intensity area by velocity increments from each side of its CV value. When the integration is lower than sqrt{N}*NoiseRMS, the limit is kept (with N the number of velocity cannals used for the integration and NoiseRMS the noise rms). When the two limits are obtained, change values of the mask from 0 to 1 inside these limits for each spectra. Last, multiplication of the mask to the cube. \n\nOUTPUT DESCRIPTION   Return the cube masked and the mean of the noise accross the map (one sigma).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI","page":"Detailed API","title":"CVI","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Functionforcvi]\nPages = [\"Functionforcvi.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Functionforcvi.construct_cvimap!-Tuple{Any, Int64, Any, Any, Array{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}}","page":"Detailed API","title":"Functionforcvi.construct_cvimap!","text":"construct_cvimap!(xyarr,Lag::Int64,nangle,mapdim,cvi_averaged::Array{Union{Missing, Float64}},cvi_allangle::Array{Union{Missing,Float64},3}; diff=\"relative\",keepmissing=true)\n\nWill construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cviaveraged), and another for the cvi calculated with all angle and lag (cviallangle). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.construct_cvimap!-Tuple{Any, Vector{Int64}, Any, Any, Matrix{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}, Array{Union{Missing, Float64}, 3}}","page":"Detailed API","title":"Functionforcvi.construct_cvimap!","text":"construct_cvimap!(xyarr,Lag::Vector{Int64},nangle,mapdim,cvi_averaged_alllag::Array{Union{Missing, Float64},2},cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle::Array{Union{Missing,Float64},3}; diff=\"relative\",keepmissing=true)\n\nWill construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cvimean), and another for the cvi calculated with all angle and lag (cviallanglealllag). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.construct_cvimap-Tuple{Any, Int64, Any, Any}","page":"Detailed API","title":"Functionforcvi.construct_cvimap","text":"construct_cvimap(xyarr,Lag::Int64,nangle,mapdim; diff=\"relative\",keepmissing=true)\n\nSame as construct_cvimap if Lag is a Int64 of one lag. Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.construct_cvimap-Tuple{Any, Vector{Int64}, Any, Any}","page":"Detailed API","title":"Functionforcvi.construct_cvimap","text":"construct_cvimap(xyarr,Lag::Vector{Int64},mapdim,blank)\n\nWill construct a cvi map. The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. Nangle refers to the number of rotations of the cvmap: a higher value will compute a higher number of differences pixel per pixel, so a higher number of directions.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.construct_cvmap-Tuple{Any, Any}","page":"Detailed API","title":"Functionforcvi.construct_cvmap","text":"construct_cvmap(xyarr,velvector)\n\nWill construct a cv map by calculating the first velocity moment order of the array and replace the inf values by NaN. xyarr have to be in 2D (pixel*pixel), while velvector have to be in 1D (velocities).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.cv_increment!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}, 3}}","page":"Detailed API","title":"Functionforcvi.cv_increment!","text":"cv_increment!(xyarr,Lag::Int64,blank,cvimap_lag::Array{Union{Missing,Float64},2})\n\nSame as (xyarr,Lag::Int64,nangle; diff=\"relative\",periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cvi_allangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.cv_increment!-Tuple{Any, Vector{Int64}, Any, Array{Union{Missing, Float64}, 3}, Any}","page":"Detailed API","title":"Functionforcvi.cv_increment!","text":"cv_increment!(xyarr,Lag::Vector{Int64},nangle,cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle ; diff=\"relative\",periodic=false)\n\nSame as cvincrement(xyarr,Lag::Vector{Int64},nangle; diff=\"relative\",periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cviallangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle) and cviallanglealllag = Array{Union{Missing,Float64},3}(undef,DataDimension[1]*DataDimension[2],nangle,size(Lag)[1])\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.cv_increment-Tuple{Any, Int64, Any, Any}","page":"Detailed API","title":"Functionforcvi.cv_increment","text":"cv_increment(xyarr,Lag::Int64,nangle; diff=\"relative\",periodic=false)\n\nCompute the centroid velocity increment of xyarr at one Lag. Nangle is the number of angle using to compute the differences (it's a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first two dimensions equal to the size of the map, and the third dimension is the cvi computed at each angle.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.cv_increment-Tuple{Any, Vector{Int64}, Any}","page":"Detailed API","title":"Functionforcvi.cv_increment","text":"cv_increment(xyarr,Lag::Vector{Int64},nangle; diff=\"relative\",periodic=false)\n\nCompute the centroid velocity increment of xyarr at multiple Lag values. Nangle is the number of angle using to compute the differences (it's a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first dimension equal to the size of the map (pixel square), the second dimension is the cvi computed at each angle, and the third dimension is for each value of Lag.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.delete_aberations-Tuple{Any, Any}","page":"Detailed API","title":"Functionforcvi.delete_aberations","text":"delete_aberations(arr1,arr2)\n\nReplace values in arr1 which are higher or lower than values in arr2 by missing. Don't use an arr1 with missing values !\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.moment_four-Tuple{Any, Any}","page":"Detailed API","title":"Functionforcvi.moment_four","text":"moment_four(yarr,xarr)\n\nReturn the fourth moment order of xarr weighted by yarr.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.moment_one-Tuple{Any, Any}","page":"Detailed API","title":"Functionforcvi.moment_one","text":"moment_one(yarr,xarr)\n\nCompute the first moment order of the array xarr weighted by yarr. Centroid = int(T*v)dv/int(T)dv\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.moment_one_field-Tuple{Any, Any, Any}","page":"Detailed API","title":"Functionforcvi.moment_one_field","text":"moment_one_field(arr,velvector)\n\nReturn the first moment order of all pixels in an entire field, weighted by velvector. Arr can be a 3D array (ppv) or a 2D array (pv)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.moment_three-Tuple{Any, Any}","page":"Detailed API","title":"Functionforcvi.moment_three","text":"moment_three(yarr,xarr)\n\nReturn the third moment order of xarr weighted by yarr.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.moment_two-Tuple{Any, Any}","page":"Detailed API","title":"Functionforcvi.moment_two","text":"moment_two(yarr,xarr)\n\nReturn the second moment order of xarr weighted by yarr.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.moment_two_field-Tuple{Any, Any}","page":"Detailed API","title":"Functionforcvi.moment_two_field","text":"moment_two_field(arr,velvector)\n\nReturn the order 2 moment of an entire field.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforcvi.multiple_moment-Tuple{Array{Float64, 3}, Any}","page":"Detailed API","title":"Functionforcvi.multiple_moment","text":"multiple_moment(cube::Array{Float64,3},velvector)\n\nReturn the first or second velocity moment order of a 3D array. The 3D array in input have its first dimension giving the pixel position, the second dimension giving spectra, and the third dimension giving other data with the same dimensions. This function was built in order to obtain in the third dimensions multiple centroid velocity maps with data reconstructed from different number of principal component (see Principal Component Analysis)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphical-representations","page":"Detailed API","title":"Graphical representations","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Graphic]\nPages = [\"Graphic.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Graphic.StcFct-NTuple{4, Any}","page":"Detailed API","title":"Graphic.StcFct","text":"StcFct()\n\nPlot structure functions of orders p in function of the structure function of order 3. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.StcFctExponent-NTuple{7, Any}","page":"Detailed API","title":"Graphic.StcFctExponent","text":"StcFctExponent(zeta,third_order_zeta,OrderP,xlim,ylim,labs,data_name_title,directories_name; add=false,save=true,pcfinal=0)\n\nPlot the exponent of the structure function power-law fit in function of the order p of the structure function. If add is true, the plot will be added on the actual plot. Also add a y=1/3x line on the plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.StcFctExponentWithError-NTuple{10, Any}","page":"Detailed API","title":"Graphic.StcFctExponentWithError","text":"StcFctExponentWithError()\n\nPlot the exponent of the structure function power-law fit in function of the order p of the structure function. Compute and plot also the error of the fit. If add is true, the plot will be added on the actual plot. Also add a y=1/3x line on the plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.StcFctWithFit-NTuple{6, Any}","page":"Detailed API","title":"Graphic.StcFctWithFit","text":"StcFctWithFit()\n\nPlot structure functions of orders p in function of the structure function of order 3 with the fit used to obtain the power-law exponent. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.animate_ppvcube-Tuple{Any, Any, Any}","page":"Detailed API","title":"Graphic.animate_ppvcube","text":"animate_ppvcube(cube,data_name)\n\nPlot a heatmap of a 3D cube along third dimension, and save it as a gif file.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.animate_spectra-NTuple{5, Any}","page":"Detailed API","title":"Graphic.animate_spectra","text":"animate_spectra(arr,positionnumber,direction)\n\nMake an animation (.gif) plotting all the spectrum of a line of pixels (dims=1) or a row of pixels (dims=2). Array has to be 3D. Used the array, the position of the line or the row, and the direction (line=1 or row=2).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.checkwindowopti-NTuple{5, Any}","page":"Detailed API","title":"Graphic.checkwindowopti","text":"\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.contourmap-NTuple{5, Any}","page":"Detailed API","title":"Graphic.contourmap","text":"contourmap(arr,arraytocontour,lev,xvec,yvec)\n\nPlot the data arr in heatmap type and contours in front at levels=lev. Contours can be provided from another data. Arr has to be 2D.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.corner_cvimap-NTuple{5, Any}","page":"Detailed API","title":"Graphic.corner_cvimap","text":"corner_cvimap(array1,array2,datadim,labelarray1,labelarray2)\n\nMake a cornerplot between each element of the third dimension of array2, and also compare with array1. Array1 has to be 1D (cvi pixel values), and array2 has to be 2D (cvi pixel values and different cvi maps obtained (with different PC for example)). Labelarray1 has to be 1 String, Labelarray2 has to be an array os String, with as elements as the third dimension of array2. [\"dollars(ix) PC\" for ix=2:4] to label the named of the third dimension of array2 has number of PC used\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.cvi_pdf-NTuple{10, Any}","page":"Detailed API","title":"Graphic.cvi_pdf","text":"cvi_pdf(data,para0,bin,ylim1,ylim2,alph,Lag,data_name_title,legend ; add=false)\n\nPlot the pdf of the cvi, WIP : and add a gaussian fit on the data. By default, will do a new plot. If add=true, will add this plot on the last figure created.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.cvi_pdf_norm-Tuple{KernelDensity.UnivariateKDE, Any, Any, Any, Any, Any, Any}","page":"Detailed API","title":"Graphic.cvi_pdf_norm","text":"cvi_pdf_norm(data,sigm,bin,ylim1,ylim2,alph,Lag,data_name_title,legend ; add=false)\n\nPlot the pdf of the cvi, WIP : and add a gaussian fit on the data. By default, will do a new plot. If add=true, will add this plot on the last figure created.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.heatmap_compare_multiplepc-Tuple{Any, Any, Any, Any, Any, Any, Any, String, Bool, Any}","page":"Detailed API","title":"Graphic.heatmap_compare_multiplepc","text":"compare_rawpc(xvec1,yvec1,array1,dimens,xvec2,yvec2,arraypc,title1::String,saveall::Bool,field)\n\nPlot multiple files, each with two heatmap : the first is a heatmap of the array1 (same for all file), the second a heatmap of the arraypc which change for each file in order to plot all of its third dimension (Data reconstructed with different number of PC for example). Array1 has to be 2D (PixelPixel), arraypc has to be 3D (PixelPixel*PC). The subplots of each files have the same colorscale.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.heatmap_interacted-Tuple{Any, Any, Any}","page":"Detailed API","title":"Graphic.heatmap_interacted","text":"heatmap_interacted(data,delta_xvec,delta_yvec)\n\nWill produce a heatmap plot of a 2d dataset, with colorscale changing by an interaction of the user on a slider.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.heatmap_subplot_same-Tuple{Any, Any, Any}","page":"Detailed API","title":"Graphic.heatmap_subplot_same","text":"heatmap_subplot_same(arr,j,velocity_range)\n\nMade a subplot in a heatmap form, using the one data but plotting different velocity canals (velocity_range). J is the position of the first plot.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.heatmap_subplot_two-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, String, String, Bool, Any, Any}","page":"Detailed API","title":"Graphic.heatmap_subplot_two","text":"heatmap_subplot_two(xvec1,yvec1,array1,xvec2,yvec2,array2,lim1,lim2,title1,title2,save,field)\n\nMade a subplot in a heatmap form, using two different data (array1 and array2) with a defined colorbar scale (lim1 and lim2), their x and y coordinates (xvec1,yvec1 and xvec2,yvec2) a title for each plot (title1 and title 2), if the plot need to be saved (save) and where.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.ifdiff-NTuple{8, Any}","page":"Detailed API","title":"Graphic.ifdiff","text":"ifdiff(spectratokeep,array1,reconstructed_array,velocity_vector,datadim,titl,nbrow,nbcol)\n\nPlot the spectra associate with absolute differences in moment calculation (N moment order or CV) higher than a threshold between two data cube. Plot also the differences of the spectra. Arraymoment and reconstructedmoment are two 2D arrays, while array1 and reconstructed_array are 3D data cube (PPV).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.ifdiff_cvmap-NTuple{7, Any}","page":"Detailed API","title":"Graphic.ifdiff_cvmap","text":"ifdiff_cvmap(cvmap,specdiff_map,xvec,yvec,lim1,lim2,titl)\n\nAdd the specdiffmap on the plot of the cvmap . Specdiffmap can be a map where each pixel missing is a spectrq giving a difference in the CV calculation > to a threshold, qnd the others pixels are equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.meanpc-Tuple{Any, Any, Int64, Any, Any, String, String, Bool, String, Bool}","page":"Detailed API","title":"Graphic.meanpc","text":"meanpc\n\nPlot two images in one plot : the first is the mean of all the spectrums of a data (using directly the rawdat, will be meaned in the function), the second is the data reconstructed with N PC (npc) obtained by a pca method on these data, using M which is a PCA object type introduced in MultivariateStats package. Need the scales of the color bars (scale1 and scale2), the titles of each plot (title1 and title2), a boolean to know if the plot need to be saved (save), the name of the save if needed (filename), and if the plots needs to be display. Arr can be 2D array (PV) or a 3D array (PPV).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.mom_conv-Tuple{Any, Any, Any, Any, Any, Int64, Any, Any, Any}","page":"Detailed API","title":"Graphic.mom_conv","text":"mom_conv(momarray,array_specavr,velocity_vector,pcnumb,momentorder,nbrow,nbcol,velocity_range)\n\nSame as the function moment_byintegration, but all plotted in different subplot in the same file. Pcnumb is a vector with all PC number you work with. Momentorder should be equal to the moment number you want to plot (used for the title).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.moment_byintegration-NTuple{4, Any}","page":"Detailed API","title":"Graphic.moment_byintegration","text":"moment_byintegration(momarray,pcnumb,velocity_vector,momentorder)\n\nPlot the 3rd or 4th moment order of the differences of integrated by sections spectras between original data (without PCA) and reconstructed data with PCA. Pcnumb is a vector with all PC number you work with. Momentorder should be equal to the moment number you want to plot (used for the title).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.moment_multiplepc-NTuple{7, Any}","page":"Detailed API","title":"Graphic.moment_multiplepc","text":"moment_multiplepc(moment_multiplepc,pcnumb,nbrow,nbcol,titl,limx,limy;disp=false)\n\nDisplay scatter subplots comparing moment maps (N moment order or CV) obtain with different number of PC. NPC is compared with (N-1)PC. A linear function y=x is also plotted. Moment_multiplepc is a 3D array where the third dimension gives different maps calculated with a number of PC different.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.moment_multiplepc_withraw-NTuple{6, Any}","page":"Detailed API","title":"Graphic.moment_multiplepc_withraw","text":"moment_multiplepc_withraw(moment_multiplepc,pcnumb,array1,nbrow,nbcol,titl)\n\nSame as moment_multiplepc but compare each moment maps obtain with different number of PC with the original data (without PC). A linear function y=x is also plotted.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.moment_specific_canals-Tuple{Any, Any, Any}","page":"Detailed API","title":"Graphic.moment_specific_canals","text":"moment_specific_canals(moment_pca,moment_nopca,data_name,pcmax)\n\nPlot a file with 4 subplots, each showing a moment calculation on the mean intensity of specific canals (generally associated with noise). 'momentpca' are the moments calculated on data reconstructed from PCA, and 'momentnopca' the moments calculated on the original data set.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.pcacompwo-NTuple{4, Any}","page":"Detailed API","title":"Graphic.pcacompwo","text":"\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.pixels_averaged_spectrum-Tuple{Any, Any, Any, Any, Any, Tuple, Any, Any}","page":"Detailed API","title":"Graphic.pixels_averaged_spectrum","text":"pixels_averaged_spectrum(arr,arr2,nbrow,nbcol,titl,pixel_range::Tuple,blank,vel1)\n\nPlot the averaged spectrums of two cube arr and arr2. The average is doing on a square of (pixelrange)  by (pixelrange) pixels.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.pixels_averaged_spectrum-Tuple{Any, Any, Any, Any, Tuple, Any, Any}","page":"Detailed API","title":"Graphic.pixels_averaged_spectrum","text":"pixels_averaged_spectrum(arr,nbrow,nbcol,titl,pixel_range:Tuple,blank,vel1)\n\nPlot the averaged spectrums of a data. The average is doing on a square of (pixelrange[1]) by (pixelrange[2]) pixels.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.pixels_averaged_spectrum_twodata-NTuple{9, Any}","page":"Detailed API","title":"Graphic.pixels_averaged_spectrum_twodata","text":"pixels_averaged_spectrum_twodata(arr,reconstructed_array,nbrow,nbcol,titl,pixel_range,blank,vel1,vel2)\n\nPlot the averaged spectrums of two fits : the rawdata and the data reconstructed from a PCA applied to these rawdata, with two velocity vectors different. The average is doing on a square of (pixelrange)  by (pixelrange) pixels.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.ploptiwind-NTuple{5, Any}","page":"Detailed API","title":"Graphic.ploptiwind","text":"\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.plpc-Tuple{Any, Integer, Any}","page":"Detailed API","title":"Graphic.plpc","text":"    plpc(Yt,pc)\n\nPlot some principal components (PC) of data analysed by a PCA. Yt is the transformation of the raw data into principal components.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.pratio-Tuple{Any, Bool, Any, Any}","page":"Detailed API","title":"Graphic.pratio","text":"pratio(M::PCA,ylog::Bool,pc,titl)\n\nPlot the explained percentage of the data per principal component. If ylog is True, the yaxis will be plotted in log. Pc arguments are used to name the plot.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.region_spectrum-Tuple{}","page":"Detailed API","title":"Graphic.region_spectrum","text":"region_spectrum\n\nPlot spectra from a specific region\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.region_spectrum_twodata-NTuple{7, Any}","page":"Detailed API","title":"Graphic.region_spectrum_twodata","text":"region_spectrum_twodata\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.sci_not-Tuple{Any, Any}","page":"Detailed API","title":"Graphic.sci_not","text":"sci_not(x,ndec)\n\nUsed to transform axis x labelling in scientific notation with ndec the number of decimals.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Function-for-fBms-data-based","page":"Detailed API","title":"Function for fBms data based","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Functionforfbm]\nPages = [\"Functionforfbm.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Functionforfbm.fbm2D-Tuple{Any, Any}","page":"Detailed API","title":"Functionforfbm.fbm2D","text":"fbm2D(imsize,powerlaw ; disp = false)\n\nConstruct a 2D fbm map of size imsize*imsize, following a power spectrum law equal to powerlaw. Can plot the map (disp = true).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforfbm.power_spectra-Tuple{Any, Any, Any}","page":"Detailed API","title":"Functionforfbm.power_spectra","text":"power_spectra(arr,karr,imsize ; fitted=true)\n\nCompute the power spectrum of arr, print and plot it. karr is the frequencies array (pixel^-1). Also add a powerlaw fit by default.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforfbm.ppv_from_fbm-NTuple{6, Any}","page":"Detailed API","title":"Functionforfbm.ppv_from_fbm","text":"ppv_from_fbm(imsize,powerlaw,xarray,sig,stdev,tmax)\n\nCompute a ppv cube, with two gaussian components centered on the values obtained in 2D fbm maps minus the mean of the xarray (== velocity array). A noise with a standard deviation of stdev is added.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforfbm.ppv_from_fbm2-NTuple{7, Any}","page":"Detailed API","title":"Functionforfbm.ppv_from_fbm2","text":"ppv_from_fbm2(imsize,powerlaw,xarray,sig,stdev,tmax)\n\nCompute a ppv cube, with one gaussian components centered on the values obtained in 2D fbm maps minus the mean of the xarray (== velocity array). A noise with a standard deviation of stdev is added.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functionforfbm.ppv_from_fbm4-NTuple{10, Any}","page":"Detailed API","title":"Functionforfbm.ppv_from_fbm4","text":"ppv_from_fbm4(imsize,powerlaw,xarray,sig,stdev,tmax)\n\nCompute a ppv cube, with 4 gaussian components of maxima equal to the values obtained in 2D fbm maps minus the mean of the xarray (== velocity array). A noise with a standard deviation of stdev is added. Xarray is the velocity axis wanted (write it as : -20:01:20 for example) xinc is an array (3 of size) given the increments for each components. sig is an array (3 of size) given the dispersions. A random value will also be added.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functions-for-Data-Analysis","page":"Detailed API","title":"Functions for Data Analysis","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Data_analysis]\nPages = [\"Data_analysis.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Data_analysis.calcmetric-NTuple{5, Any}","page":"Detailed API","title":"Data_analysis.calcmetric","text":"calcmetric(mom1,mom2,mom3,mom4,dv)\n\nCalculate the following metric on each values of mom1,2,3 and 4: sqrt((mom1/dv)2+(mom2/dv)2+(mom3)2+(mom4-3)2)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.find_indices-Tuple{Any, Any}","page":"Detailed API","title":"Data_analysis.find_indices","text":"find_indices(specdiff,arra ; dims = size(arra))\n\nReturn an array of the same dimension than arra where the indices in specdiff are equal to 1000, and others indices are equal to 0. Dims indicates the dimensions of the returned array (by default same as in input). Use this if some dimensions should not be used.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.find_threshold-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_analysis.find_threshold","text":"find_threshold(array1,array2,thresh)\n\nReturn an array with each value being the index where abs(array1[indice]-array2[indice]) is greater than a threshold.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.fourmoments-Tuple{Any}","page":"Detailed API","title":"Data_analysis.fourmoments","text":"fourmoments(cube;dim=1)\n\nCompute the first four moments order of a given cube of dimension 'dim'. If 2D PV cube, will compute the moments on each row. Return the four moments. They are Vector of dimension=size(cube)[1]\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.generate_gaussian-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_analysis.generate_gaussian","text":"generate_gaussian(xarray,mu,sig)\n\nProduce a gaussian and a normalized gaussian, following mu and sigma.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.integration_bysection-NTuple{4, Any}","page":"Detailed API","title":"Data_analysis.integration_bysection","text":"integration_bysection(data2D,integration_range,datadim,increment)\n\nCompute an integration of spectra with a given increment, for each spectra in a map. Return an array with the first dimension giving a different spectra, and the second dimension giving the integration sections.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.rms_analytic-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_analysis.rms_analytic","text":"rms_analytic(yarr,rms,xarr)\n\nReturn the uncertainty of the first moment order in velocity, and some part of the analytical expression. Yarr represents the emission part of the data, xarr the velocity vector.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.rms_analytic_field-Tuple{Any, Any, Any}","page":"Detailed API","title":"Data_analysis.rms_analytic_field","text":"rms_analytic_field(array1,xarr,noise_canals)\n\nReturn the uncertainty of the first moment order in velocity of a field, and some part of the analytical expression. Xarr represents the velocity vector. Array1 is a 2D data cube, with each row a new pixel and the columns forms the spectra.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.snr-Tuple{Any, Any}","page":"Detailed API","title":"Data_analysis.snr","text":"snr(yarr,noise_canals)\n\nReturn the SNR of a signal (spectra for example). yarr have to be a vector.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_analysis.snr_allfield-Tuple{Any, Any}","page":"Detailed API","title":"Data_analysis.snr_allfield","text":"snr_allfield(arr,noise_canals)\n\nReturn the mean of the SNR calculated on several spectra. Arr can be 2D (PV) or 3D (PPV) but will be faster if 2D. Better to avoid missing values in your data.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations","page":"Detailed API","title":"WORK IN PROGRESS : Function for Structure functions computations","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Structure_fct]\nPages = [\"Structure_fct.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Structure_fct.construct_fctstruct!-Tuple{Any, Any, Any, Any, Tuple{Int64, Int64}, Any, Any}","page":"Detailed API","title":"Structure_fct.construct_fctstruct!","text":"construct_fctstruct!\n\nConstruct a matrix with the values of the structure functions at every given lag and orders (lag in columns and orders in lines). Need a preallocated array.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_fct.construct_fctstruct-Tuple{Any, Any, Any, Any, Tuple{Int64, Int64}, Any}","page":"Detailed API","title":"Structure_fct.construct_fctstruct","text":"construct_fctstruct\n\nConstruct a matrix with the values of the structure functions at every given lag and orders (lag in lines and orders in columns).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_fct.fct_struct-NTuple{6, Any}","page":"Detailed API","title":"Structure_fct.fct_struct","text":"fct_struct(data,datapdf,order,bin)\n\nCompute the structure function of a data at a specific order.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_fct.fit_fctstruct-Tuple{Any, Any, Any}","page":"Detailed API","title":"Structure_fct.fit_fctstruct","text":"fit_fctstruct(xdata,ydata,y0,confidinterv ; confinterv=true)\n\nFit the model ydata=A*(xdata)^B. Can return the confidence interval too of the model. Return in first B, then A.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_fct.pdf_normed-Tuple{Any, Any, Tuple, Any}","page":"Detailed API","title":"Structure_fct.pdf_normed","text":"pdf_normed(data,bin,bound::Tuple)\n\nCompute the PDF of the data given, and normalize it by centered at 0 mean, a standard deviation of unity and an area=1.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_fct.xhi_fct_p-NTuple{4, Any}","page":"Detailed API","title":"Structure_fct.xhi_fct_p","text":"xhi_fct_p(pvec,struct_lag,lagvec,y0,confidinterv)\n\nFit the model y=A*(x)^B for multiple order and lag of structure functions.\n\n\n\n\n\n","category":"method"},{"location":"Quickguide.html#Quick-guide","page":"Quick guide","title":"Quick guide","text":"","category":"section"},{"location":"Quickguide.html#Installation","page":"Quick guide","title":"Installation","text":"","category":"section"},{"location":"Quickguide.html#Running-scripts","page":"Quick guide","title":"Running scripts","text":"","category":"section"},{"location":"Unveil.html#Functions-inside-Unveil.jl","page":"Main functions of Unveil","title":"Functions inside Unveil.jl","text":"","category":"section"},{"location":"Unveil.html","page":"Main functions of Unveil","title":"Main functions of Unveil","text":"Modules = [Unveil]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"index.html#Unveil.jl","page":"Unveil.jl","title":"Unveil.jl","text":"","category":"section"},{"location":"index.html","page":"Unveil.jl","title":"Unveil.jl","text":"Documentation for Unveil.jl","category":"page"},{"location":"Others.html#Description","page":"Functions used by Unveil and more","title":"Description","text":"","category":"section"},{"location":"Others.html#Data-Prep","page":"Functions used by Unveil and more","title":"Data Prep","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Data_preparation]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#PCA","page":"Functions used by Unveil and more","title":"PCA","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Functionforpca]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#SWO","page":"Functions used by Unveil and more","title":"SWO","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Spectralwindowopti]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#CVI","page":"Functions used by Unveil and more","title":"CVI","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Functionforcvi]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#Graphical-representations","page":"Functions used by Unveil and more","title":"Graphical representations","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Graphic]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#Functions-for-fBms-data-based","page":"Functions used by Unveil and more","title":"Functions for fBms data based","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Functionforfbm]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#Functions-for-Data-analysis","page":"Functions used by Unveil and more","title":"Functions for Data analysis","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Data_analysis]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#WORK-IN-PROGRESS-:-Functions-for-Structure-functions-computations","page":"Functions used by Unveil and more","title":"WORK IN PROGRESS : Functions for Structure functions computations","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil and more","title":"Functions used by Unveil and more","text":"Modules = [Structure_fct]\nOrder   = [:constant, :type, :function, :macro]","category":"page"}]
}
