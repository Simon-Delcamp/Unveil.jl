var documenterSearchIndex = {"docs":
[{"location":"Api.html#Description","page":"Detailed API","title":"Description","text":"","category":"section"},{"location":"Api.html#Unveil","page":"Detailed API","title":"Unveil","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Unveil]\nPages = [\"Unveil.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Unveil.combinecv-Tuple{}","page":"Detailed API","title":"Unveil.combinecv","text":"WORK IN PROGRESS Combine multiple CV maps into one cube.  Use this script in a julia terminal with :     julia>Unveil.combinecv()\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.compmethod_stcfct-Tuple{Any}","page":"Detailed API","title":"Unveil.compmethod_stcfct","text":"Comparing PCA and SWO method by printing exponant of the structure functions with the order on the same figure\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.convpca-Tuple{Any}","page":"Detailed API","title":"Unveil.convpca","text":"convpca(VARFILEPATH)\n\nCompute the PCA convergence criteria based on the matrix projection from PCA. No PCA reconstructed cube will be saved. A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/convpca.txt').\n\nOUTPUTS : A plots with every moments of the projection matrix + the metric (see the doc). Also add a .dat file with moments, metric and number of PC used for each.\n\nUse this script in a julia terminal with :     julia>Unveil.convpca(\"VARFILEPATH\")\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.cv-Tuple{Any}","page":"Detailed API","title":"Unveil.cv","text":"cv(VARFILEPATH)\n\nCalculate the CV from a cube given in input. A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/cv.txt').\n\nUse this script in a julia terminal with :     julia>Unveil.cv(VARFILEPATH)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.cvcvi-Tuple{Any}","page":"Detailed API","title":"Unveil.cvcvi","text":"cvcvi(VARFILEPATH)\n\nCalculate the CV and CVI from a cube given in input. A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/cvcvi.txt').\n\nUse this script in a julia terminal with :     julia>Unveil.cvcvi(VARFILEPATH)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.cvi-Tuple{Any}","page":"Detailed API","title":"Unveil.cvi","text":"cvi(VARFILEPATH)\n\nCalculate the CVI from a CV map. A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/cvi.txt'). \n\nINPUT : path to the variable '.txt' file OUTPUTS : Save the CV fits, \n\nUse this script in a julia terminal with :     julia>Unveil.cvi(VARFILEPATH)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.multipca-Tuple{Any}","page":"Detailed API","title":"Unveil.multipca","text":"multipca(VARFILEPATH)\n\nUse multiple PCA processes on a cube and with multiple numbers of PCs given as input. A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/multipca.txt').\n\nOUTPUTS : One file per cube reconstructed with one of the number of PC given as an input.\n\nUse this script in a julia terminal with :     julia>Unveil.multipca(VARFILEPATH)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.pca-Tuple{Any}","page":"Detailed API","title":"Unveil.pca","text":"pca(VARFILEPATH)\n\nUse a PCA (Principal Component Analysis) process on a cube and with N PCs given as input. A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/pca.txt'). \n\nINPUTS : path to the variable '.txt' file OUTPUTS : save a cube reconstructed by the number of PC asked in the '.txt' file\n\nUse this function in a julia terminal with :     julia> Unveil.pca(VARFILEPATH)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.structure_functions-Tuple{Any}","page":"Detailed API","title":"Unveil.structure_functions","text":"structure_functions(VARFILEPATH)\n\nCompute the structure functions S_p(l) of a cvi cube (following definition in Kritsuk+2007). A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/structure_functions.txt'). The cube given as input should be a CVI (use function Unveil.cvi if needed). Prefer a cube with rotations of every lags than azimutal average, like that : (Pixel positions,angles,lag). \n\nOUTPUTS : One figure with S_p(l) vs S_3(l), same with fit, and exponants of S_p(l) function of p. Also a .dat file with values of the exponants. Use this function in a julia terminal with :     julia> Unveil.structure_functions(VARFILEPATH)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Unveil.swo-Tuple{Any}","page":"Detailed API","title":"Unveil.swo","text":"swo(VARFILEPATH)\n\nUse a SWO (Spectral Window Optimisation) process on a cube. A '.txt' file should be used accordingly as an input (see models inside folders '/varfiles/swo.txt').\n\nUse this function in a julia terminal with :     julia> Unveil.swo(VARFILEPATH)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Data_preparation","page":"Detailed API","title":"Data_preparation","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Dataprep]\nPages = [\"Dataprep.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Dataprep.addblank-NTuple{4, Any}","page":"Detailed API","title":"Dataprep.addblank","text":"addblank(data,missing_arr,blank,data_dimension)\n\nReconstruct a data with missing values after they where deleted. Usually deleted in order to compute a PCA. Can reconstruct 3D cubes (e.g. PPV) as well as 2D maps (PP). In the first case, the input missingarr should be in 2D, while in the second case it should be in 1D. The input missingarr is produces with the function Datapreparation.pcaprep. The input data should be a 1D vector. Data_dimension has to be equal to the dimension you want to obtain.      To reproduce a 3D cube, it should have blank values at the exact same positions across the 3rd dimension. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.blank_equal-Tuple{Any, Any, Any}","page":"Detailed API","title":"Dataprep.blank_equal","text":"blank_equal(array,oldvalue,newvalue)\n\nChange the values equals to a value by another one in an array. This is useful if change of blanking is desired. You have to use the function \"replace_nantoblank\" if the old value is NaN.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.blank_inf-Tuple{Any, Any, Any}","page":"Detailed API","title":"Dataprep.blank_inf","text":"blank_inf(array,oldvalue,newvalue)\n\nChange the values tinier than an old value to a new value in an array. This is useful if a change of blanking is desired\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.boolmatrix_missing-Tuple{Any}","page":"Detailed API","title":"Dataprep.boolmatrix_missing","text":"boolmatrix_missing(array)\n\nReturn a 1D and a 2D boolean matrices indicating the indexes of missing values in array. Array should be a 2 dimension data (pixels*spectra for example)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.delete_allnotvalue-Tuple{Any, Any}","page":"Detailed API","title":"Dataprep.delete_allnotvalue","text":"delete_allnotvalue(data,blank)\n\nDelete from data all value which are not a valid value, e.g. missing, NaN and blank.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.deletemissing-Tuple{Any, Any}","page":"Detailed API","title":"Dataprep.deletemissing","text":"deletemissing(data,missing1D)\n\nDelete all rows where there is at least one missing value using a boolean vector of the missing values.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.directory_prep-Tuple{Any}","page":"Detailed API","title":"Dataprep.directory_prep","text":"directory_prep(PATHTOSAVE::String)\n\nConstruct a new directory to save plots of the convergence criteria (Convergence_Criteria) process and another to save the fits (Data).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.pca_prep-Tuple{Any, Any}","page":"Detailed API","title":"Dataprep.pca_prep","text":"pca_prep(arr,arraydimension)\n\nPrepare data (given in 2D (pv) or 3D (ppv)) in order to conduct PCA on them by deleting missing values and reshape in 2D.\n\nWill also check if any missing value still exist in the data, showing that the data are not regularly blanked. Return data in 2 dimensions without missing value, a 1D boolean matrix to check if any missing value still exist in the data (if 0 element then no missing value) and a 2D matrix with booleans corresponding to missing values in the dataset (used to reconstruct the data with the missing values).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.permcolrow-Tuple{Any}","page":"Detailed API","title":"Dataprep.permcolrow","text":"permcolrow(arr)\n\nReturn the array with the first and second dimensions permuted. 2D and 3D arrays accepted.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.prodvarfile-Tuple{}","page":"Detailed API","title":"Dataprep.prodvarfile","text":"prodvarfile(;PATH=\".\",com=true)\n\nCreate the .txt varfiles needed as input of Unveil code. By default at the directory where Unveil is run. Can change the directory with option PATH. Comments can be removed with option 'com' set to false.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.read_dat-Tuple{Any}","page":"Detailed API","title":"Dataprep.read_dat","text":"read_dat(DATFILEPATH ; com='#')\n\nReturn values of the .dat file given as input. By default, will consider as comment rows starting with a #. Can be changed.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.read_dim-Tuple{Any}","page":"Detailed API","title":"Dataprep.read_dim","text":"read_dim(arr)\n\nReturn a vector with dimensions of the data.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.read_fits_cvi-Tuple{Any}","page":"Detailed API","title":"Dataprep.read_fits_cvi","text":"read_fits_cvi(path ; check = true)\n\nReturn the cube, its dimension and its header. Use to read CVI cube, with this order : Pixel position, Rotation, LAG.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.read_fits_pp-Tuple{Any}","page":"Detailed API","title":"Dataprep.read_fits_pp","text":"read_fits_pp(path)\n\nRead a 2D fits (pixel*pixel). Return values (matrix), header and dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.read_fits_ppv-Tuple{Any, Any}","page":"Detailed API","title":"Dataprep.read_fits_ppv","text":"read_fits_ppv(path,vel_units ; check = true)\n\nRead data of a PPV fits from its path, test if the fits is conform, then return : [1] Data in an array [2] Range of velocity in an array (in km/s) [3] Dimensions of the data (one vector with each element a dimension) [4] The velocity resolution (in km/s) [5] The header of the fits If the header does not contain any third dimension indication, the function will still return the data, the dimension and the header. Velocities need to be in the third dimension. This function conduct a sanity check by default. Give check = false if you don't want the test being conducted.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.read_var_files-Tuple{Any}","page":"Detailed API","title":"Dataprep.read_var_files","text":"read_var_files(varfile_path)\n\nA function to read and import values of a variable files. The variable files can be anywhere in the machine, but preferentially localised in the \"var_file\" folders.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.regular_blanking-Tuple{Any}","page":"Detailed API","title":"Dataprep.regular_blanking","text":"regular_blanking(data)\n\nCheck if the data of a fits file contains any irregular blanking e.g. a spectra with one blanking value (or more, but less than the spectra size).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.replace_blanktomissing-Tuple{Any, Any}","page":"Detailed API","title":"Dataprep.replace_blanktomissing","text":"replace_blanktomissing(arr,blanktomissing)\n\nReplace specific values (blanktomissing, generally blank value) by missing value in an array.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.replace_inf_in_nan-Tuple{Any}","page":"Detailed API","title":"Dataprep.replace_inf_in_nan","text":"replace_inf_in_nan(arr)\n\nReplace the Inf values by NaN values. Useful when searching for max and min values in the array.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.replace_missingtoblank-Tuple{Any, Any}","page":"Detailed API","title":"Dataprep.replace_missingtoblank","text":"replace_missingtoblank(arr,missingtoblank)\n\nReplace missing values by a 'missingtoblank' value in an array (generally a blank value).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.replace_nantoblank-Tuple{Any, Any}","page":"Detailed API","title":"Dataprep.replace_nantoblank","text":"replace_nantoblank(data,blank)\n\nReplace the NaN values in an array by a new blank value.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.replace_nantomissing-Tuple{Any}","page":"Detailed API","title":"Dataprep.replace_nantomissing","text":"replace_nantomissing(data)\n\nReplace the NaN values in an array by missing value.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.replace_nosignal-NTuple{5, Any}","page":"Detailed API","title":"Dataprep.replace_nosignal","text":"function replace_nosignal(cube,DATADIMENSION,VELOCITYVECTOR,BLANK,SIGMAMAP)\n\nReplace spectra without signal by blank value. We recover the spectra without signal by compute the intensity integration of each of them. If it is less than 2 times the dispersion of the noise, then it is blanked. SIGMAMAP is the 2D map of each rms noise of your cube ; use Dataanalysis.rmscube(cube,NOISECAN)[1] to compute it.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.write_dat-Tuple{Any, Any, Any}","page":"Detailed API","title":"Dataprep.write_dat","text":"write_dat(matrix,PATHTOSAVE,NAME ; more=[\"\"], overwrite=false)\n\nWrite matrix in a .dat file. Each column of the matrix is writen as new column in the file. Delimiters are spaces by default. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true. If want to add more entries on the header of the dat, use the option 'more'. Will be added as commentaries with a # at the begining of the line.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Dataprep.write_fits-Tuple{String, String, String, Any, Any, Any}","page":"Detailed API","title":"Dataprep.write_fits","text":"write_fits(fitstocopy::String,newname::String,pathtosave::String,datatosave,datadim,blank ; finished=true)\n\nCreate a fits with its own header based on 'fitstocopy', and with the name 'newfits'. DO NOT ADD THE EXTENSION (e.g \".fits\") FOR THE NAME OF THE NEWFITS). Need to give the blanking value. The fits can be constructed by data with two dimensions or three dimensions. Variable 'finished' is by default true, so the function will by default close the new fits file at the end of the execution of this function. If 'finished' is false, the function will not close the fits file, allowing it to be modified again in another function (createcvifits for example). If want to add more entries on the header, use the option 'more'. Alternate between the name printed in the header and the value. Example, if want to add an entry for 'imsize' equals to 50, and an entry for 'powerlaw' equals to -3, write : more=[\"imsize\",\"50\",\"powerlaw\",\"-3\"]. The option overwrite is false by default. If want to overwrite file with the same name as given in input, change it to true.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#PCA","page":"Detailed API","title":"PCA","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [PCA]\nPages = [\"PCA.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#PCA.pca-Tuple{Any, Integer, String}","page":"Detailed API","title":"PCA.pca","text":"    pca(data2D,pc::Integer,path::String ; percent=1.0)\n\nProduce a Principal Component Analysis on a data, using 'pc' number of principal component. 'percent' gives the wanted percentage of variance reconstructed (default=1). 'path' is the path where results will be saved (in 'bin' temporary files, named as mmapYt.bin, mmapMproj.bin and mmapMmean.bin) Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the path to the projections of the data2D on the PC axis, the mean of these projections, the path to the matrix composed of the principal components in columns and the percentage of explained variance. These results will allow to reconstruct the cube with a given number of PC (using pcanomorecalc).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#PCA.pca-Tuple{Any, Integer}","page":"Detailed API","title":"PCA.pca","text":"    pca(data2D,pc::Integer ; percent=1.0)\n\nProduce a Principal Component Analysis on a data, using 'pc' number of principal component. 'percent' gives the wanted percentage of variance reconstructed (default=1).  Data are converted in an Array{Float64,2} to do the PCA ( type as Union{Missing} will produce an error). Data should be given in 2D (pixels per velocities). Will return the pca fit M (a type created by the MultivariateStats package), the matrix composed of the principal components in columns, the percentage of explained variance and the data reconstructed with 'pc' number of principal component. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#PCA.pca_nomorecalc-NTuple{5, Any}","page":"Detailed API","title":"PCA.pca_nomorecalc","text":"    pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim)\n\nReconstruct data with a certain number of PC, without redo all of the PCA calculation. Necessary to do a first pca calculation to run this one, because needed M (a new type related to PCA constructed by MultivariateStats package) and Yt (matrix with each column a PC). Datadim should be a tuple with two values (PV cube, 2D) or three (PPV cube, 3D).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#PCA.pca_nomorecalc-Tuple{String, String, String, Any, Any, Any}","page":"Detailed API","title":"PCA.pca_nomorecalc","text":"    pca_nomorecalc(Mproj_path::String,Yt_path::String,Mmean_path::String,pcfirst,pclast,datadim)\n\nSame as pca_nomorecalc(M,Yt,pcfirst,pclast,Datadim) but using here the path to the temporary files containing the informations (M and Yt). To be used after pca(data2D,pc::Integer,path::String ; percent=1.0) in order to produce a reconstructed cube.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#SWO","page":"Detailed API","title":"SWO","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [SWO]\nPages = [\"SWO.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#SWO.petysnr-NTuple{4, Any}","page":"Detailed API","title":"SWO.petysnr","text":"petysnr(cubesource,DATADIMENSION_NOMISSING,VELOCITYVECTOR,NOISECAN)\n\nMethod from Pety+2003, similar to the SWO method and used in the same way.\n\nINPUT : cubesource, the cube whom you want to compute the SWO. It should be in 2D (PxP,V), as DATADIMENSION_NOMISSING, which gives the total dimensions of the cube. VELOCITYVECTOR is the velocity vector, computed and given as output of the function Dataprep.read_fits_ppv. NOISECAN are some of the velocity channels of the cube where there is only noise. Used to compute the dispersion of the noise of cubesource.\n\nOUTPUT : [1] Cubesource with SWO mask applied (inside mask windows are equal to cubesource, outside is 0)           [2] Mask of SWO method computed on cubesource\n\n\n\n\n\n","category":"method"},{"location":"Api.html#SWO.swo-NTuple{4, Any}","page":"Detailed API","title":"SWO.swo","text":"swo(cubesource,DATADIMENSION_NOMISSING,VELOCITYVECTOR,NOISECAN)\n\nMethod SWO (Spectral Window Optimisation). For each spectra of the cubesource, look for the maximum SNR given by :\n\nSNR(v_texti)=fracsum_texti=1^textmT_textisqrtmsigma_1m\n\nIn this equation, T_texti is the intensity at velocity channel v_texti, and sigma_1m the dispersion computed between velocity channels 1 to m. The SNR is computed in increasing velocity channels, then in decreasing velocity channels. Each maxima of these two computations will give one window limit containing the emission.\n\nINPUT : cubesource, the cube whom you want to compute the SWO. It should be in 2D (PxP,V), as DATADIMENSION_NOMISSING, which gives the total dimensions of the cube. VELOCITYVECTOR is the velocity vector, computed and given as output of the function Dataprep.read_fits_ppv. NOISECAN are some of the velocity channels of the cube where there is only noise. Used to compute the dispersion of the noise of cubesource.\n\nOUTPUT : [1] Cubesource with SWO mask applied (inside mask windows are equal to cubesource, outside is 0)           [2] Mask of SWO method computed on cubesource\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI","page":"Detailed API","title":"CVI","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [CVI]\nPages = [\"CVI.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#CVI.construct_cvimap!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}}","page":"Detailed API","title":"CVI.construct_cvimap!","text":"construct_cvimap!(xyarr,Lag::Int64,mapdim,cvi_averaged::Array{Union{Missing, Float64}},cvi_allangle::Array{Union{Missing,Float64},3}; diff=\"relative\",keepmissing=true)\n\nWill construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cviaveraged), and another for the cvi calculated with all angle and lag (cviallangle). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.construct_cvimap!-Tuple{Any, Vector{Int64}, Any, Any, Matrix{Union{Missing, Float64}}, Array{Union{Missing, Float64}, 3}, Array{Union{Missing, Float64}, 3}}","page":"Detailed API","title":"CVI.construct_cvimap!","text":"construct_cvimap!(xyarr,Lag::Vector{Int64},mapdim,cvi_averaged_alllag::Array{Union{Missing, Float64},2},cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle::Array{Union{Missing,Float64},3}; diff=\"relative\",keepmissing=true)\n\nWill construct a cvi map using preallocated array. Need an array preallocated for the storage of the average on all cvi angle (cvimean), and another for the cvi calculated with all angle and lag (cviallanglealllag). The cvi map is constructed by taking the mean of all rotations of the cv increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.construct_cvimap-Tuple{Any, Int64, Any}","page":"Detailed API","title":"CVI.construct_cvimap","text":"construct_cvimap(cvmap,Lag::Int64,mapdim; diff=\"relative\",keepmissing=true)\n\nSame as construct_cvimap if Lag is a Int64 of one lag. Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.construct_cvimap-Tuple{Any, Vector{Int64}, Any}","page":"Detailed API","title":"CVI.construct_cvimap","text":"construct_cvimap(cvmap,Lag::Vector{Int64},mapdim; diff=\"relative\",keepmissing=true,BLANK=-1000)\n\nConstruct a Centroid Velocity Increment map based on a 'cvmap'. The cvi map is constructed by taking the mean of all rotations of the Centroid Velocity Increment calculation at each pixel. The Lag is the increment. xyarr have to be in 2D (pixel*pixel). Mapdim is the dimension of your 2Dmap. The differences can be absolute or relative. \n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.cv_increment!-Tuple{Any, Int64, Any, Array{Union{Missing, Float64}, 3}}","page":"Detailed API","title":"CVI.cv_increment!","text":"cv_increment!(xyarr,Lag::Int64,blank,cvimap_lag::Array{Union{Missing,Float64},2})\n\nSame as (xyarr,Lag::Int64,nangle; diff=\"relative\",periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cvi_allangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle).\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.cv_increment!-Tuple{Any, Vector{Int64}, Any, Array{Union{Missing, Float64}, 3}, Any}","page":"Detailed API","title":"CVI.cv_increment!","text":"cv_increment!(xyarr,Lag::Vector{Int64},nangle,cvi_allangle_alllag::Array{Union{Missing, Float64}, 3},cvi_allangle ; diff=\"relative\",periodic=false)\n\nSame as cvincrement(xyarr,Lag::Vector{Int64},nangle; diff=\"relative\",periodic=false) but on preallocated array (array produced outside this function). To produce the array, use : cviallangle = Array{Union{Missing,Float64},3}(undef,DataDimension[1],DataDimension[2],nangle) and cviallanglealllag = Array{Union{Missing,Float64},3}(undef,DataDimension[1]*DataDimension[2],nangle,size(Lag)[1])\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.cv_increment-Tuple{Any, Int64, Any, Any}","page":"Detailed API","title":"CVI.cv_increment","text":"cv_increment(xyarr,Lag::Int64,nangle; diff=\"relative\",periodic=false)\n\nCompute the centroid velocity increment of xyarr at one Lag. Nangle is the number of angle using to compute the differences (it's a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first two dimensions equal to the size of the map, and the third dimension is the cvi computed at each angle.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.cv_increment-Tuple{Any, Vector{Int64}, Any}","page":"Detailed API","title":"CVI.cv_increment","text":"cv_increment(xyarr,Lag::Vector{Int64},nangle; diff=\"relative\",periodic=false)\n\nCompute the centroid velocity increment of xyarr at multiple Lag values. Nangle is the number of angle using to compute the differences (it's a value in the parameter file, equal to 192). Diff (default relative) is for differences between two pixels : absolute or relative. Periodic=true (default=false) is for working on periodic data (from simulations like fbm). The returned array will have the first dimension equal to the size of the map (pixel square), the second dimension is the cvi computed at each angle, and the third dimension is for each value of Lag.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.moment_one-Tuple{Any, Any}","page":"Detailed API","title":"CVI.moment_one","text":"moment_one(yarr,xarr)\n\nCompute the first moment order of the array xarr weighted by yarr. Centroid = int(T*v)dv/int(T)dv\n\n\n\n\n\n","category":"method"},{"location":"Api.html#CVI.moment_one_field-NTuple{5, Any}","page":"Detailed API","title":"CVI.moment_one_field","text":"moment_one_field(arr,velvector)\n\nReturn the first moment order of all pixels in an entire field, weighted by velvector. Arr can be a 3D array (ppv) or a 2D array (pv). The function replace all missing values by \n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphical-representations","page":"Detailed API","title":"Graphical representations","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Graphic]\nPages = [\"Graphic.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Graphic.StcFct-NTuple{4, Any}","page":"Detailed API","title":"Graphic.StcFct","text":"StcFct()\n\nPlot structure functions of orders p in function of the structure function of order 3. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.StcFctExponent-NTuple{7, Any}","page":"Detailed API","title":"Graphic.StcFctExponent","text":"StcFctExponent(zeta,third_order_zeta,OrderP,xlim,ylim,labs,data_name_title,directories_name; add=false,save=true,pcfinal=0)\n\nPlot the exponent of the structure function power-law fit in function of the order p of the structure function. If add is true, the plot will be added on the actual plot. Also add a y=1/3x line on the plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.StcFctWithFit-NTuple{6, Any}","page":"Detailed API","title":"Graphic.StcFctWithFit","text":"StcFctWithFit()\n\nPlot structure functions of orders p in function of the structure function of order 3 with the fit used to obtain the power-law exponent. If add is true, the plot will be added on the actual plot. The figure can be saved with the number of PC used during the process in the name by changing pcfinal.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.energyspec-NTuple{4, Any}","page":"Detailed API","title":"Graphic.energyspec","text":"energyspec(powerspec,karr,imsize,PATHTOSAVE;fitted=true,SAVENAME=\"\")\n\nPlot an energy power spectra. karr is the frequencies array (pixel^-1). Also add a powerlaw fit by default.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Graphic.pratio-Tuple{Any, Bool, Any, Any}","page":"Detailed API","title":"Graphic.pratio","text":"pratio(M::PCA,ylog::Bool,pc,titl)\n\nPlot the explained percentage of the data per principal component. If ylog is True, the yaxis will be plotted in log. Pc arguments are used to name the plot.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Functions-for-Data-Analysis","page":"Detailed API","title":"Functions for Data Analysis","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Analysis]\nPages = [\"Analysis.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Analysis.fourmoments-Tuple{Any}","page":"Detailed API","title":"Analysis.fourmoments","text":"fourmoments(cube;dim=2)\n\nCompute the first four moments order of a given cube of dimension 'dim'. If 2D PV cube, will compute the moments on each row. Return the four moments. They are Vector of dimension=size(cube)[1]\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Analysis.metricOW-NTuple{6, Any}","page":"Detailed API","title":"Analysis.metricOW","text":"metricOW(mom1,mom2,mom3,mom4,dv,SIGMAT)\n\nCalculate the following metric on each values of mom1,2,3 and 4: sqrt((mom1)2+((mom2-SIGMAT))2+(mom3)2+(mom4-3)2)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Analysis.metricPCA-NTuple{6, Any}","page":"Detailed API","title":"Analysis.metricPCA","text":"metricPCA(mom1,mom2,mom3,mom4)\n\nCalculate the following metric on each values of mom1,2,3 and 4: sqrt((mom1/dv)2+(mom2/dv)2+(mom3)2+(mom4-3)2)\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Analysis.power_spectra-Tuple{Any, Any}","page":"Detailed API","title":"Analysis.power_spectra","text":"power_spectra(arr,imsize ; fitted=true)\n\nCompute the power spectrum of arr, and return it with the Fourier domain vector.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Analysis.rms_cube-Tuple{Array{Float64, 3}, Any}","page":"Detailed API","title":"Analysis.rms_cube","text":"rms_cube(cube,can)\n\nCompute the dispersion (e.g. sqrt(moment order 2)) on velocity canal given as input of a cube. Return a 2D map with given dispersion on each pixel and the averaged dispersion accross the map.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Analysis.rms_cube-Tuple{Matrix{Float64}, Any}","page":"Detailed API","title":"Analysis.rms_cube","text":"rms_cube(cube,can)\n\nCompute the dispersion (e.g. sqrt(second moment order)) on velocity canal given as input of a cube. Return a 2D map with given dispersion on each pixel and the averaged variance accross the map.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#WORK-IN-PROGRESS-:-Function-for-Structure-functions-computations","page":"Detailed API","title":"WORK IN PROGRESS : Function for Structure functions computations","text":"","category":"section"},{"location":"Api.html","page":"Detailed API","title":"Detailed API","text":"Modules = [Structure_functions]\nPages = [Structure_functions.jl\"]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Api.html#Structure_functions.fct_sct-Tuple{Any, Any, Any}","page":"Detailed API","title":"Structure_functions.fct_sct","text":"fct_sct(cvicube,LAG,ORDERS)\n\nCompute the structure functions from Monin & Yaglom+75 method.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_functions.fct_sct_int-Tuple{Any, Any, Any}","page":"Detailed API","title":"Structure_functions.fct_sct_int","text":"fctsctint(cvicube,LAG,ORDERS)\n\nCompute the structure functions from Hily-Blant+08 method.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_functions.fit_fctsct-Tuple{Any, Any, Any}","page":"Detailed API","title":"Structure_functions.fit_fctsct","text":"fit_fctstruct(xdata,ydata,y0,confidinterv)\n\nFit the model ydata=A*(xdata)^B. Return in first B, then A.\n\n\n\n\n\n","category":"method"},{"location":"Api.html#Structure_functions.xhi_fct_p-Tuple{Any, Any}","page":"Detailed API","title":"Structure_functions.xhi_fct_p","text":"xhi_fct_p(pvec,struct_lag,y0)\n\nFit the model y=A*(x)^B for multiple order and lag of structure functions.\n\n\n\n\n\n","category":"method"},{"location":"Quickguide.html#Presentation","page":"Quick guide","title":"Presentation","text":"","category":"section"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"This code unveil positions of extreme intermittent dissipation of turbulence on PPV cubes obtained by observing molecular gas inside molecular clouds. It uses statistical analysis by computing Centroid Velocity Increments, based on Lis et al. 1996, Pety et al. 1999, Hily-Blant et al. 2007, Hily-Blant et al. 2008, Hily-Blant et al. 2009, and on the PhD thesis of Simon Delcamp (in prep). ","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"One of the original features of the Unveil.jl analysis code is its ability to estimate uncertainties in statistical markers. On the one hand, Unveil.jl provides two independent methods of data treatment: the Spectral Window Optimisation (SWO), inspired by the work of Pety+2003, and a data compression using Principal Component Analysis (PCA). These two methods were tested on numerical simulations in order to calibrate the parameters of use, providing strong recommendations on the SNR required for observations. The code's ability to measure the statistical properties of turbulence was tested on magnetohydrodynamic numerical simulations covering sub- to supersonic and sub- to superAlfvénic regimes.","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"The idea is to give quick and simple tools to interested researchers, written in a new, promising and well maintain programming language for him to evolve. ","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"The module Unveil.jl is the main one. It contains 8 functions, each one comunicating with others modules inside this package. To be able to use one function of Unveil, you should first produce a '.txt' variable file. This allow to use functions with high numbers or long inputs more easily and quickier. Examples of these .txt files can be produced with the function Unveil.prodvarfile().","category":"page"},{"location":"Quickguide.html#Installation","page":"Quick guide","title":"Installation","text":"","category":"section"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"This package is not registered in the General registry of Julia, following the recommended practices (the functionalities of this package will mainly be used by a small group of researchers).","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"However, the package installation is still simple. While in the local directory where you want to install it, two commands are needed : inside Julia, type :","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://gricad-gitlab.univ-grenoble-alpes.fr/delcamps/unveil\")","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"<!–-The second command will ask you to enter your Username and your Password. For the Username, just enter the one you are using to connect to gitlab (email adress probably). For the Password, you need a \"Project Access Tokens\". ","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"Project Access Tokens : Go to the project directory, into Settings then Access Tokens. Here, enter a Token name, remove the expiration date, select a role, check the box \"api\", and click on create. A new project access token will be prompt above : save it inside your local computer, it will nether be prompt again !","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"After that, everything inside the gitlab repo will be saved in the directory you are working in. –->","category":"page"},{"location":"Quickguide.html#Rules","page":"Quick guide","title":"Rules","text":"","category":"section"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"To be used correctly, few rules should be followed : ","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"All files should be .fits\nFor better results, it is highly recommanded to blank the maps edges, and/or the noisiest spectra. \nFor a PPV (Position-Position-Velocity) cube, at one given position in PP space, if one velocity channel is blanked, it should be blanked on every others velocity channels. We call that regular blanking. If not, the code will throw an error. \nThe fits header should contain these three entries : \"BLANK\", \"BZERO\" and \"BSCALE\". See this list of keywords definition of the fits file convention for more informations. If these entries don't exist, an error will be print.","category":"page"},{"location":"Quickguide.html#Running-it","page":"Quick guide","title":"Running it","text":"","category":"section"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"First, in julia, enter : ","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"julia> using Unveil","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"From that, every functions of the package can be used. The first function to use is :","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"julia> Unveil.prodvarfile()","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"It will create all .txt variable files needed to run the other functions. Each function has an associated .txt file where variables are indicated (e.g fits path, values of the lags, ...).  They are used by given these modified txt files as input. For example you want to produce a PCA, just enter :","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"julia> Unveil.pca('path-to-the-txt-file')","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"Numerous others functions of this package can be used. They are inside others modules and should be used accordingly. For example, you can change every \"NaN\" positions to a given one in a PPV cube : ","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"julia> cube = Unveil.Data_preparation.read_fits_ppv(path,vel_units)[1]   # Read the fits inside 'path'. Need the unit of the veloity dimension\njulia> Unveil.Data_preparation.replace_nantoblank(cube,newvalue)   # Change all NaN inside 'cube' into 'newvalue'","category":"page"},{"location":"Quickguide.html","page":"Quick guide","title":"Quick guide","text":"For a list and description of every function, please see the doc : download the folder 'docs/build' and open the '.html' files inside it. ","category":"page"},{"location":"Unveil.html#Functions-inside-Unveil.jl","page":"Main functions of Unveil","title":"Functions inside Unveil.jl","text":"","category":"section"},{"location":"Unveil.html","page":"Main functions of Unveil","title":"Main functions of Unveil","text":"Modules = [Unveil]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Unveil.html","page":"Main functions of Unveil","title":"Main functions of Unveil","text":"Modules = [Unveil]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"index.html#Unveil.jl","page":"Unveil.jl","title":"Unveil.jl","text":"","category":"section"},{"location":"index.html","page":"Unveil.jl","title":"Unveil.jl","text":"Documentation for Unveil.jl","category":"page"},{"location":"Others.html#Description-a-name\"Others\"/a","page":"Functions used by Unveil","title":"Description <a name=\"Others\"></a>","text":"","category":"section"},{"location":"Others.html#Data-Prep","page":"Functions used by Unveil","title":"Data Prep","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil","title":"Functions used by Unveil","text":"Modules = [Dataprep]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#PCA","page":"Functions used by Unveil","title":"PCA","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil","title":"Functions used by Unveil","text":"Modules = [PCA]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#SWO","page":"Functions used by Unveil","title":"SWO","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil","title":"Functions used by Unveil","text":"Modules = [SWO]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#CVI","page":"Functions used by Unveil","title":"CVI","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil","title":"Functions used by Unveil","text":"Modules = [CVI]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#Graphical-representations","page":"Functions used by Unveil","title":"Graphical representations","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil","title":"Functions used by Unveil","text":"Modules = [Graphic]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#Functions-for-Data-analysis","page":"Functions used by Unveil","title":"Functions for Data analysis","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil","title":"Functions used by Unveil","text":"Modules = [Analysis]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"Others.html#WORK-IN-PROGRESS-:-Functions-for-Structure-functions-computations","page":"Functions used by Unveil","title":"WORK IN PROGRESS : Functions for Structure functions computations","text":"","category":"section"},{"location":"Others.html","page":"Functions used by Unveil","title":"Functions used by Unveil","text":"Modules = [Structure_functions]\nOrder   = [:constant, :type, :function, :macro]","category":"page"}]
}
